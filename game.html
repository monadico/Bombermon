<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Bomberman - MultiSynq</title>
    <script src="https://cdn.jsdelivr.net/npm/@multisynq/client@latest/bundled/multisynq-client.min.js"></script>
    <script src="https://kaboomjs.com/lib/0.6.0/kaboom.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            background: #000;
            border: 3px solid #333;
            border-radius: 8px;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        
        #playerList {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            min-width: 150px;
        }
        
        .player-info {
            margin-bottom: 5px;
            padding: 3px;
            border-radius: 3px;
        }
        
        .player-local {
            background: rgba(0, 255, 0, 0.2);
            border-left: 3px solid #0f0;
        }
        
        .player-remote {
            background: rgba(255, 255, 0, 0.2);
            border-left: 3px solid #ff0;
        }
    </style>
</head>
<body>
    <!-- Background Music -->
    <audio id="backgroundMusic" loop>
        <source src="8-bit-retro-game-music-233964.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- Sound Effects -->
    <audio id="explosionSound" preload="auto">
        <source src="explosion.mp3" type="audio/mpeg">
    </audio>
    <audio id="powerupSound" preload="auto">
        <source src="powerup.mp3" type="audio/mpeg">
    </audio>
    <audio id="deathSound" preload="auto">
        <source src="dead_scream.mp3" type="audio/mpeg">
    </audio>
    
    <div id="gameContainer">
        <div id="ui">
            <div>Lives: <span id="lives">3</span></div>
            <div>Bombs: <span id="bombs">1</span></div>
            <div>Fire: <span id="fire">1</span></div>
            <div id="gameStatus">Waiting for players...</div>
            <div>ðŸŽµ <button id="musicToggle" style="background: #00ff88; color: #000; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Music: ON</button></div>
        </div>
        
        <div id="playerList">
            <div style="font-weight: bold; margin-bottom: 10px;">Players:</div>
            <div id="players"></div>
        </div>
    </div>

    <script>
        // Game constants
        const TILE_SIZE = 26;
        const MOVE_SPEED = 130;
        const BOMB_TIMER = 3;
        const EXPLOSION_DURATION = 1;
        
        // Initialize Kaboom.js
        kaboom({
            global: true,
            width: 780,
            height: 520,
            scale: 1.5,
            debug: false,
            clearColor: [0, 0, 0, 1],
            canvas: document.querySelector('#gameContainer canvas') || undefined
        });

        // Load sprites - using correct paths
        loadSprite('wall-steel', 'sprites/wall-steel.png'); 
        loadSprite('brick-red', 'sprites/brick-red.png');
        loadSprite('door', 'sprites/door.png');
        loadSprite('kaboom', 'sprites/kaboom.png');
        loadSprite('bg', 'sprites/bg.png');
        loadSprite('wall-gold', 'sprites/wall-gold.png');
        loadSprite('brick-wood', 'sprites/brick-wood.png');

        // Load Bomberman sprite with animations
        loadSprite('bomberman', 'images/bombermon.png', {
            sliceX: 7,
            sliceY: 4,
            anims: {
                idleUp: { from: 0, to: 0 },
                moveUp: { from: 1, to: 6 },
                idleRight: { from: 7, to: 7 },
                moveRight: { from: 8, to: 13 },
                idleDown: { from: 14, to: 14 },
                moveDown: { from: 15, to: 20 },
                idleLeft: { from: 21, to: 21 },
                moveLeft: { from: 22, to: 27 },
            }
        });

        // Load bomb and explosion sprites
        loadSprite('bomb', 'sprites/bomb.png', {
            sliceX: 3,
            anims: { tick: { from: 0, to: 2 } }
        });

        loadSprite('explosion', 'sprites/explosion.png', { 
            sliceX: 5,
            sliceY: 5,
        });

        // Power-up sprites
        loadSprite('powerup-bomb', 'sprites/powerup-bomb.png');
        loadSprite('powerup-fire', 'sprites/powerup-fire.png');
        loadSprite('powerup-speed', 'sprites/powerup-speed.png');

        // MultiSynq Models
        class GameModel extends Multisynq.Model {
            init() {
                this.players = new Map(); // viewId -> PlayerModel
                this.bombs = new Set();   // Active bombs
                this.explosions = new Set(); // Active explosions
                this.powerUps = new Set(); // Power-ups on map
                this.gameStarted = false;
                this.gameOver = false;
                this.winner = null;
                
                // Initialize game map
                this.initializeMap();
                
                // Subscribe to player events
                this.subscribe(this.sessionId, "view-join", this.playerJoined);
                this.subscribe(this.sessionId, "view-exit", this.playerExited);
                this.subscribe(this.sessionId, "restart-game", this.restartGame);
                
                // Start main game loop
                this.mainLoop();
            }
            
            initializeMap() {
                // Level map from singleplayer version
                this.levelMap = [
                    'aaaaaaaaaaaaaaa',
                    'a @ z z z z z a',
                    'a z a z a z a a',
                    'a z z z z z z a', 
                    'a z a z a z a a',
                    'a z z z z z z a',
                    'a z a z a z a a',
                    'a z z z z z z a',
                    'a z a z a z a a',
                    'a z z z z z z a',
                    'a z a z a z a a',
                    'a z z z & z z a',
                    'a z a z a z a a',
                    'a $ z z * z # a',
                    'aaaaaaaaaaaaaaa',
                ];
                
                // Track destructible blocks
                this.destructibleBlocks = new Set();
                this.levelMap.forEach((row, y) => {
                    row.split('').forEach((cell, x) => {
                        if (cell === 'z') {
                            this.destructibleBlocks.add(`${x},${y}`);
                        }
                    });
                });
            }
            
            playerJoined(viewInfo) {
                const viewId = viewInfo.viewId;
                const playerId = this.players.size;
                
                // Spawn positions for up to 4 players
                const spawnPositions = [
                    { x: TILE_SIZE, y: TILE_SIZE },           // Top-left
                    { x: TILE_SIZE * 13, y: TILE_SIZE },      // Top-right  
                    { x: TILE_SIZE, y: TILE_SIZE * 13 },      // Bottom-left
                    { x: TILE_SIZE * 13, y: TILE_SIZE * 13 }  // Bottom-right
                ];
                
                const spawnPos = spawnPositions[playerId % 4];
                
                const player = PlayerModel.create({
                    viewId: viewId,
                    playerId: playerId,
                    position: spawnPos
                });
                
                this.players.set(viewId, player);
                
                // Start game if we have at least 2 players
                if (this.players.size >= 2 && !this.gameStarted) {
                    this.startGame();
                }
                
                this.publish(this.sessionId, "player-list-updated", {
                    players: Array.from(this.players.values()).map(p => ({
                        viewId: p.viewId,
                        playerId: p.playerId,
                        lives: p.lives,
                        isAlive: p.isAlive
                    }))
                });
            }
            
            playerExited(viewInfo) {
                const viewId = viewInfo.viewId;
                const player = this.players.get(viewId);
                if (player) {
                    player.destroy();
                    this.players.delete(viewId);
                    
                    this.publish(this.sessionId, "player-list-updated", {
                        players: Array.from(this.players.values()).map(p => ({
                            viewId: p.viewId,
                            playerId: p.playerId,
                            lives: p.lives,
                            isAlive: p.isAlive
                        }))
                    });
                }
            }
            
            startGame() {
                this.gameStarted = true;
                this.publish(this.sessionId, "game-started", {});
            }
            
            mainLoop() {
                if (!this.gameOver) {
                    // Update all players
                    for (const player of this.players.values()) {
                        player.update();
                    }
                    
                    // Update all bombs
                    for (const bomb of this.bombs) {
                        bomb.update();
                    }
                    
                    // Update explosions
                    for (const explosion of this.explosions) {
                        explosion.update();
                    }
                    
                    // Check win condition
                    this.checkWinCondition();
                }
                
                // Continue loop at ~60fps
                this.future(16).mainLoop();
            }
            
            checkWinCondition() {
                const alivePlayers = Array.from(this.players.values()).filter(p => p.isAlive);
                
                if (alivePlayers.length <= 1 && this.players.size > 1) {
                    this.gameOver = true;
                    this.winner = alivePlayers.length === 1 ? alivePlayers[0].viewId : null;
                    this.publish(this.sessionId, "game-over", {
                        winner: this.winner,
                        winnerName: this.winner ? `Player ${alivePlayers[0].playerId + 1}` : "Draw"
                    });
                }
            }
            
            restartGame() {
                // Reset game state
                this.gameOver = false;
                this.gameStarted = false;
                this.winner = null;
                
                // Clear all bombs, explosions, and power-ups
                this.bombs.clear();
                this.explosions.clear();
                this.powerUps.clear();
                
                // Reset map
                this.initializeMap();
                
                // Reset all players
                const spawnPositions = [
                    { x: TILE_SIZE, y: TILE_SIZE },           
                    { x: TILE_SIZE * 13, y: TILE_SIZE },      
                    { x: TILE_SIZE, y: TILE_SIZE * 13 },      
                    { x: TILE_SIZE * 13, y: TILE_SIZE * 13 }  
                ];
                
                let playerIndex = 0;
                for (const player of this.players.values()) {
                    player.pos = spawnPositions[playerIndex % 4];
                    player.lives = 3;
                    player.bombCount = 1;
                    player.firePower = 1;
                    player.isAlive = true;
                    player.isMoving = false;
                    player.targetPos = null;
                    player.currentAnimation = 'idleDown';
                    player.lastDirection = 'down';
                    playerIndex++;
                }
                
                // Start game again
                if (this.players.size >= 2) {
                    this.startGame();
                }
                
                this.publish(this.sessionId, "game-restarted", {});
            }
            
            isValidPosition(pos, excludePlayer = null) {
                const gridX = Math.round(pos.x / TILE_SIZE);
                const gridY = Math.round(pos.y / TILE_SIZE);
                
                // Check boundaries
                if (gridX < 0 || gridY < 0 || gridX >= 15 || gridY >= 15) {
                    return false;
                }
                
                // Check map obstacles
                if (gridY < this.levelMap.length && gridX < this.levelMap[gridY].length) {
                    const cell = this.levelMap[gridY].charAt(gridX);
                    if (cell === 'a') return false; // Steel wall
                    if (cell === 'z' && this.destructibleBlocks.has(`${gridX},${gridY}`)) {
                        return false; // Brick wall
                    }
                }
                
                // Check for bombs
                for (const bomb of this.bombs) {
                    if (this.positionsOverlap(bomb.pos, pos)) {
                        return false;
                    }
                }
                
                return true;
            }
            
            positionsOverlap(pos1, pos2, threshold = TILE_SIZE / 2) {
                return Math.abs(pos1.x - pos2.x) < threshold && 
                       Math.abs(pos1.y - pos2.y) < threshold;
            }
            
            snapToGrid(pos) {
                return {
                    x: Math.round(pos.x / TILE_SIZE) * TILE_SIZE,
                    y: Math.round(pos.y / TILE_SIZE) * TILE_SIZE
                };
            }
        }
        GameModel.register("GameModel");

        class PlayerModel extends Multisynq.Model {
            init({ viewId, playerId, position }) {
                this.viewId = viewId;
                this.playerId = playerId;
                this.pos = position;
                this.lives = 3;
                this.bombCount = 1;
                this.firePower = 1;
                this.isAlive = true;
                this.isMoving = false;
                this.targetPos = null;
                this.lastDirection = 'down';
                this.currentAnimation = 'idleDown';
                this.moveProgress = 0;
                this.lastMoveTime = 0;
                this.lastBombTime = 0;
                
                // Subscribe to input events from this player's view
                this.subscribe(viewId, "move", this.handleMove);
                this.subscribe(viewId, "place-bomb", this.placeBomb);
            }
            
            get game() {
                return this.wellKnownModel("modelRoot");
            }
            
            handleMove(data) {
                if (!this.isAlive || this.isMoving || this.game.gameOver) return;
                
                const { direction } = data;
                const now = this.now();
                
                // Rate limiting - prevent too rapid movement
                if (now - this.lastMoveTime < 160) return;
                
                const targetPos = this.calculateTargetPosition(direction);
                
                if (this.game.isValidPosition(targetPos, this)) {
                    this.startMovement(direction, targetPos);
                    this.lastMoveTime = now;
                }
            }
            
            calculateTargetPosition(direction) {
                switch(direction) {
                    case 'left':
                        return { x: this.pos.x - TILE_SIZE, y: this.pos.y };
                    case 'right':
                        return { x: this.pos.x + TILE_SIZE, y: this.pos.y };
                    case 'up':
                        return { x: this.pos.x, y: this.pos.y - TILE_SIZE };
                    case 'down':
                        return { x: this.pos.x, y: this.pos.y + TILE_SIZE };
                    default:
                        return this.pos;
                }
            }
            
            startMovement(direction, targetPos) {
                this.isMoving = true;
                this.targetPos = targetPos;
                this.lastDirection = direction;
                this.currentAnimation = `move${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
                this.moveProgress = 0;
                
                // Start movement interpolation
                this.interpolateMovement();
            }
            
            interpolateMovement() {
                if (!this.isMoving) return;
                
                this.moveProgress += 0.15; // Movement speed
                
                if (this.moveProgress >= 1.0) {
                    // Movement complete
                    this.pos = this.targetPos;
                    this.isMoving = false;
                    this.moveProgress = 0;
                    this.currentAnimation = `idle${this.lastDirection.charAt(0).toUpperCase() + this.lastDirection.slice(1)}`;
                } else {
                    // Continue interpolation
                    this.future(16).interpolateMovement();
                }
            }
            
            getCurrentPosition() {
                if (!this.isMoving || !this.targetPos) {
                    return this.pos;
                }
                
                // Interpolate position for smooth movement
                return {
                    x: this.pos.x + (this.targetPos.x - this.pos.x) * this.moveProgress,
                    y: this.pos.y + (this.targetPos.y - this.pos.y) * this.moveProgress
                };
            }
            
            placeBomb() {
                if (!this.isAlive || this.game.gameOver) return;
                
                const now = this.now();
                if (now - this.lastBombTime < 500) return; // Rate limiting
                
                const bombPos = this.game.snapToGrid(this.pos);
                
                // Check if there's already a bomb at this position
                for (const bomb of this.game.bombs) {
                    if (this.game.positionsOverlap(bomb.pos, bombPos)) {
                        return;
                    }
                }
                
                BombModel.create({
                    position: bombPos,
                    owner: this,
                    firePower: this.firePower
                });
                
                this.lastBombTime = now;
            }
            
            takeDamage() {
                if (!this.isAlive) return;
                
                this.lives--;
                
                if (this.lives <= 0) {
                    this.isAlive = false;
                } else {
                    // Respawn at original spawn position
                    const spawnPositions = [
                        { x: TILE_SIZE, y: TILE_SIZE },           
                        { x: TILE_SIZE * 13, y: TILE_SIZE },      
                        { x: TILE_SIZE, y: TILE_SIZE * 13 },      
                        { x: TILE_SIZE * 13, y: TILE_SIZE * 13 }  
                    ];
                    this.pos = spawnPositions[this.playerId % 4];
                    this.isMoving = false;
                    this.targetPos = null;
                }
                
                // Notify view of player state change
                this.publish(this.viewId, "player-damaged", {
                    lives: this.lives,
                    isAlive: this.isAlive
                });
            }
            
            update() {
                // Check for power-up collection
                this.checkPowerUpCollection();
            }
            
            checkPowerUpCollection() {
                if (!this.isAlive) return;
                
                const currentPos = this.getCurrentPosition();
                
                for (const powerUp of this.game.powerUps) {
                    if (this.game.positionsOverlap(currentPos, powerUp.pos, TILE_SIZE * 0.8)) {
                        powerUp.collect(this);
                        
                        // Notify view of power-up collection
                        this.publish(this.viewId, "powerup-collected", {
                            type: powerUp.type,
                            bombCount: this.bombCount,
                            firePower: this.firePower
                        });
                        break;
                    }
                }
            }
        }
        PlayerModel.register("PlayerModel");

        class BombModel extends Multisynq.Model {
            init({ position, owner, firePower }) {
                this.pos = position;
                this.owner = owner;
                this.firePower = firePower;
                this.timer = BOMB_TIMER * 1000; // Convert to milliseconds
                
                // Add to game's bomb collection
                this.game.bombs.add(this);
                
                // Start countdown
                this.countdown();
            }
            
            get game() {
                return this.wellKnownModel("modelRoot");
            }
            
            countdown() {
                this.timer -= 100; // Decrease by 100ms
                
                if (this.timer <= 0) {
                    this.explode();
                } else {
                    this.future(100).countdown();
                }
            }
            
            explode() {
                // Remove from game
                this.game.bombs.delete(this);
                
                // Create explosion pattern
                const explosionPositions = this.calculateExplosionPattern();
                
                // Create explosion effects
                for (const pos of explosionPositions) {
                    ExplosionModel.create({
                        position: pos,
                        duration: EXPLOSION_DURATION * 1000
                    });
                    
                    // Destroy bricks
                    const gridX = Math.round(pos.x / TILE_SIZE);
                    const gridY = Math.round(pos.y / TILE_SIZE);
                    const blockKey = `${gridX},${gridY}`;
                    
                    if (this.game.destructibleBlocks.has(blockKey)) {
                        this.game.destructibleBlocks.delete(blockKey);
                        
                        // Chance to spawn power-up
                        if (this.random() < 0.3) {
                            this.spawnPowerUp(pos);
                        }
                    }
                    
                    // Damage players in explosion
                    for (const player of this.game.players.values()) {
                        if (this.game.positionsOverlap(player.getCurrentPosition(), pos)) {
                            player.takeDamage();
                        }
                    }
                }
                
                this.destroy();
            }
            
            calculateExplosionPattern() {
                const positions = [this.pos]; // Center explosion
                
                // Four directions
                const directions = [
                    { x: 0, y: -1 }, // up
                    { x: 0, y: 1 },  // down  
                    { x: -1, y: 0 }, // left
                    { x: 1, y: 0 }   // right
                ];
                
                directions.forEach(dir => {
                    for (let i = 1; i <= this.firePower; i++) {
                        const explosionPos = {
                            x: this.pos.x + (dir.x * TILE_SIZE * i),
                            y: this.pos.y + (dir.y * TILE_SIZE * i)
                        };
                        
                        const gridX = Math.round(explosionPos.x / TILE_SIZE);
                        const gridY = Math.round(explosionPos.y / TILE_SIZE);
                        
                        // Check boundaries
                        if (gridX < 0 || gridY < 0 || gridX >= 15 || gridY >= 15) {
                            break;
                        }
                        
                        // Check what's at this position in the level map
                        if (gridY < this.game.levelMap.length && gridX < this.game.levelMap[gridY].length) {
                            const cell = this.game.levelMap[gridY].charAt(gridX);
                            
                            // Steel wall stops explosion
                            if (cell === 'a') {
                                break;
                            }
                            
                            // Brick wall - explosion reaches it but stops there
                            if (cell === 'z' && this.game.destructibleBlocks.has(`${gridX},${gridY}`)) {
                                positions.push(explosionPos);
                                break;
                            }
                        }
                        
                        positions.push(explosionPos);
                    }
                });
                
                return positions;
            }
            
            spawnPowerUp(position) {
                const powerUpTypes = ['bomb', 'fire', 'speed'];
                const type = powerUpTypes[Math.floor(this.random() * powerUpTypes.length)];
                
                PowerUpModel.create({
                    position: position,
                    type: type
                });
            }
            
            update() {
                // Any per-frame bomb updates go here
            }
        }
        BombModel.register("BombModel");

        class ExplosionModel extends Multisynq.Model {
            init({ position, duration }) {
                this.pos = position;
                this.duration = duration;
                this.timeLeft = duration;
                
                // Add to game's explosion collection
                this.game.explosions.add(this);
                
                this.countdown();
            }
            
            get game() {
                return this.wellKnownModel("modelRoot");
            }
            
            countdown() {
                this.timeLeft -= 100;
                
                if (this.timeLeft <= 0) {
                    this.game.explosions.delete(this);
                    this.destroy();
                } else {
                    this.future(100).countdown();
                }
            }
            
            update() {
                // Any per-frame explosion updates go here
            }
        }
        ExplosionModel.register("ExplosionModel");

        class PowerUpModel extends Multisynq.Model {
            init({ position, type }) {
                this.pos = position;
                this.type = type;
                
                // Add to game's power-up collection
                this.game.powerUps.add(this);
            }
            
            get game() {
                return this.wellKnownModel("modelRoot");
            }
            
            collect(player) {
                switch(this.type) {
                    case 'bomb':
                        player.bombCount++;
                        break;
                    case 'fire':
                        player.firePower++;
                        break;
                    case 'speed':
                        // Speed power-up implementation
                        break;
                }
                
                this.game.powerUps.delete(this);
                this.destroy();
            }
        }
        PowerUpModel.register("PowerUpModel");

        // MultiSynq View
        class GameView extends Multisynq.View {
            constructor(model) {
                super(model);
                this.model = model;
                this.setupInput();
                this.setupUI();
                
                // Subscribe to game events
                this.subscribe(this.sessionId, "game-started", this.onGameStarted);
                this.subscribe(this.sessionId, "game-over", this.onGameOver);
                this.subscribe(this.sessionId, "game-restarted", this.onGameRestarted);
                this.subscribe(this.sessionId, "player-list-updated", this.onPlayerListUpdated);
                this.subscribe(this.viewId, "player-damaged", this.onPlayerDamaged);
                this.subscribe(this.viewId, "powerup-collected", this.onPowerUpCollected);
            }
            
            setupInput() {
                // Movement controls
                keyDown('left', () => this.publishMove('left'));
                keyDown('right', () => this.publishMove('right')); 
                keyDown('up', () => this.publishMove('up'));
                keyDown('down', () => this.publishMove('down'));
                
                // WASD alternative controls
                keyDown('a', () => this.publishMove('left'));
                keyDown('d', () => this.publishMove('right'));
                keyDown('w', () => this.publishMove('up'));
                keyDown('s', () => this.publishMove('down'));
                
                // Bomb placement
                keyPress('space', () => {
                    if (this.model.gameOver) {
                        // Restart game
                        this.publish(this.sessionId, "restart-game", {});
                    } else {
                        this.publish(this.viewId, "place-bomb", {});
                    }
                });
            }
            
            publishMove(direction) {
                if (!this.model.gameOver) {
                    this.publish(this.viewId, "move", { direction });
                }
            }
            
            setupUI() {
                this.livesEl = document.getElementById('lives');
                this.bombsEl = document.getElementById('bombs');
                this.fireEl = document.getElementById('fire');
                this.gameStatusEl = document.getElementById('gameStatus');
                this.playersEl = document.getElementById('players');
            }
            
            onGameStarted() {
                this.gameStatusEl.textContent = 'Game Started! Fight!';
            }
            
            onGameOver(data) {
                this.gameStatusEl.textContent = `Game Over! Winner: ${data.winnerName} - Press SPACE to restart`;
            }
            
            onGameRestarted() {
                this.gameStatusEl.textContent = 'Game Restarted! Fight!';
            }
            
            onPlayerListUpdated(data) {
                this.updatePlayerList(data.players);
            }
            
            onPlayerDamaged(data) {
                this.livesEl.textContent = data.lives;
            }
            
            onPowerUpCollected(data) {
                this.bombsEl.textContent = data.bombCount;
                this.fireEl.textContent = data.firePower;
            }
            
            updatePlayerList(players) {
                this.playersEl.innerHTML = '';
                players.forEach(player => {
                    const div = document.createElement('div');
                    div.className = player.viewId === this.viewId ? 'player-info player-local' : 'player-info player-remote';
                    div.innerHTML = `
                        Player ${player.playerId + 1} 
                        ${player.viewId === this.viewId ? '(You)' : ''}
                        <br>Lives: ${player.lives}
                        ${!player.isAlive ? ' (Dead)' : ''}
                    `;
                    this.playersEl.appendChild(div);
                });
            }
            
            update() {
                if (!this.model) return;
                
                // Update local player UI
                const localPlayer = this.model.players.get(this.viewId);
                if (localPlayer) {
                    this.livesEl.textContent = localPlayer.lives;
                    this.bombsEl.textContent = localPlayer.bombCount;
                    this.fireEl.textContent = localPlayer.firePower;
                }
                
                // Render game
                this.renderGame();
            }
            
            renderGame() {
                // Clear previous frame
                destroyAll();
                
                // Set up layers
                layers(['bg', 'obj', 'ui'], 'obj');
                
                // Add background
                try {
                    add([sprite('bg'), layer('bg')]);
                } catch (e) {
                    // Fallback background
                    add([rect(width(), height()), color(0.1, 0.3, 0.1), layer('bg')]);
                }
                
                // Render map
                this.renderMap();
                
                // Render power-ups
                this.renderPowerUps();
                
                // Render bombs
                this.renderBombs();
                
                // Render explosions
                this.renderExplosions();
                
                // Render players
                this.renderPlayers();
            }
            
            renderMap() {
                this.model.levelMap.forEach((row, y) => {
                    row.split('').forEach((cell, x) => {
                        const pos = vec2(x * TILE_SIZE, y * TILE_SIZE);
                        
                        if (cell === 'a') {
                            // Steel wall
                            try {
                                add([sprite('wall-steel'), pos, 'wall', solid()]);
                            } catch (e) {
                                // Fallback to colored rectangle if sprite not loaded
                                add([rect(TILE_SIZE, TILE_SIZE), pos, color(0.5, 0.5, 0.5), 'wall', solid()]);
                            }
                        } else if (cell === 'z' && this.model.destructibleBlocks.has(`${x},${y}`)) {
                            // Destructible brick
                            try {
                                add([sprite('brick-red'), pos, 'wall', 'brick', solid()]);
                            } catch (e) {
                                // Fallback to colored rectangle if sprite not loaded
                                add([rect(TILE_SIZE, TILE_SIZE), pos, color(0.8, 0.3, 0.2), 'wall', 'brick', solid()]);
                            }
                        }
                    });
                });
            }
            
            renderPowerUps() {
                for (const powerUp of this.model.powerUps) {
                    add([
                        sprite(`powerup-${powerUp.type}`),
                        pos(powerUp.pos.x, powerUp.pos.y),
                        'powerup'
                    ]);
                }
            }
            
            renderBombs() {
                for (const bomb of this.model.bombs) {
                    try {
                        const bombSprite = add([
                            sprite('bomb'),
                            pos(bomb.pos.x, bomb.pos.y),
                            'bomb'
                        ]);
                        bombSprite.play('tick');
                    } catch (e) {
                        // Fallback to colored circle if sprite not loaded
                        add([
                            circle(TILE_SIZE / 3),
                            pos(bomb.pos.x + TILE_SIZE/2, bomb.pos.y + TILE_SIZE/2),
                            color(0.2, 0.2, 0.2),
                            outline(2),
                            'bomb'
                        ]);
                    }
                }
            }
            
            renderExplosions() {
                for (const explosion of this.model.explosions) {
                    try {
                        add([
                            sprite('explosion', { frame: 12 }), // Center explosion frame
                            pos(explosion.pos.x, explosion.pos.y),
                            scale(1.5),
                            'explosion'
                        ]);
                    } catch (e) {
                        // Fallback to colored effect if sprite not loaded
                        add([
                            rect(TILE_SIZE, TILE_SIZE),
                            pos(explosion.pos.x, explosion.pos.y),
                            color(1, 0.5, 0, 0.8),
                            'explosion'
                        ]);
                    }
                }
            }
            
            renderPlayers() {
                for (const player of this.model.players.values()) {
                    if (!player.isAlive) continue;
                    
                    const currentPos = player.getCurrentPosition();
                    
                    try {
                        const playerSprite = add([
                            sprite('bomberman'),
                            pos(currentPos.x, currentPos.y),
                            scale(1.5),
                            'player',
                            {
                                viewId: player.viewId,
                                playerId: player.playerId
                            }
                        ]);
                        
                        // Play current animation
                        playerSprite.play(player.currentAnimation);
                    } catch (e) {
                        // Fallback to colored rectangle if sprite not loaded
                        const playerColors = [
                            [1, 1, 1],      // White
                            [1, 1, 0],      // Yellow  
                            [0, 1, 1],      // Cyan
                            [1, 0, 1]       // Magenta
                        ];
                        const colorIndex = player.playerId % 4;
                        add([
                            rect(TILE_SIZE - 4, TILE_SIZE - 4),
                            pos(currentPos.x + 2, currentPos.y + 2),
                            color(...playerColors[colorIndex]),
                            'player',
                            {
                                viewId: player.viewId,
                                playerId: player.playerId
                            }
                        ]);
                    }
                    
                    // Highlight local player
                    if (player.viewId === this.viewId) {
                        add([
                            rect(TILE_SIZE + 4, TILE_SIZE + 4),
                            pos(currentPos.x - 2, currentPos.y - 2),
                            outline(2),
                            color(0, 1, 0, 0.5),
                            'player-highlight'
                        ]);
                    }
                }
            }
        }

        // Background Music Management
        let backgroundMusic;
        let isMusicPlaying = true;
        
        // Sound Effects Management
        let explosionSound, powerupSound, deathSound;
        
        function initializeMusic() {
            backgroundMusic = document.getElementById('backgroundMusic');
            
            // Set volume to a reasonable level
            backgroundMusic.volume = 0.3;
            
            // Start playing when user interacts (browser autoplay policy)
            const startMusic = () => {
                if (isMusicPlaying && backgroundMusic.paused) {
                    backgroundMusic.play().catch(e => {
                        console.log('Could not autoplay music:', e);
                    });
                }
                // Remove event listeners after first interaction
                document.removeEventListener('click', startMusic);
                document.removeEventListener('keydown', startMusic);
            };
            
            // Add event listeners for user interaction
            document.addEventListener('click', startMusic);
            document.addEventListener('keydown', startMusic);
            
            // Music toggle functionality
            const musicToggle = document.getElementById('musicToggle');
            musicToggle.addEventListener('click', () => {
                if (isMusicPlaying) {
                    backgroundMusic.pause();
                    isMusicPlaying = false;
                    musicToggle.textContent = 'Music: OFF';
                    musicToggle.style.background = '#ff4444';
                } else {
                    backgroundMusic.play();
                    isMusicPlaying = true;
                    musicToggle.textContent = 'Music: ON';
                    musicToggle.style.background = '#00ff88';
                }
            });
            
            console.log('Background music initialized');
        }
        
        function initializeSoundEffects() {
            explosionSound = document.getElementById('explosionSound');
            powerupSound = document.getElementById('powerupSound');
            deathSound = document.getElementById('deathSound');
            
            // Set volumes for sound effects
            explosionSound.volume = 0.4;
            powerupSound.volume = 0.5;
            deathSound.volume = 0.6;
            
            console.log('Sound effects initialized');
        }
        
        function playExplosionSound() {
            if (explosionSound) {
                explosionSound.currentTime = 0;
                explosionSound.play().catch(e => {
                    console.log('Could not play explosion sound:', e);
                });
            }
        }
        
        function playPowerupSound() {
            if (powerupSound) {
                powerupSound.currentTime = 0;
                powerupSound.play().catch(e => {
                    console.log('Could not play powerup sound:', e);
                });
            }
        }
        
        function playDeathSound() {
            if (deathSound) {
                deathSound.currentTime = 0;
                deathSound.play().catch(e => {
                    console.log('Could not play death sound:', e);
                });
                }
            }
        
        // Start the game - sprites load asynchronously in Kaboom.js
        function startMultiSynqGame() {
            // Initialize background music and sound effects
            initializeMusic();
            initializeSoundEffects();
            
            console.log('Starting MultiSynq Bomberman game...');
            
            // Join MultiSynq session
            Multisynq.Session.join({
                apiKey: '2ggnQt2MuoVu2xcPjaevCeZUyyrX68wFDTDjL2dCOn',
                appId: 'io.multisynq.bomberman-multiplayer',
                model: GameModel,
                view: GameView,
                name: window.location.hash.slice(1) || Multisynq.App.randomSession(),
                password: Multisynq.App.randomPassword(),
                step: "auto"
            }).then(session => {
                console.log('MultiSynq session joined successfully');
                console.log('Session ID:', session.id);
                
                // Update URL with session info
                if (!window.location.hash) {
                    window.location.hash = session.id;
                }
                
                // Show session info in UI
                document.getElementById('gameStatus').textContent = `Session: ${session.id.substring(0, 8)}...`;
            }).catch(error => {
                console.error('Failed to join MultiSynq session:', error);
                document.getElementById('gameStatus').textContent = 'Failed to connect to multiplayer server';
                console.error('Error details:', error);
            });
        }
        
        // Start the game after a short delay to ensure DOM is ready
        setTimeout(startMultiSynqGame, 500);
    </script>
</body>
</html> 