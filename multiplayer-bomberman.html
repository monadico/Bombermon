<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Bomberman - Pure Canvas + MultiSynq</title>
    <script src="https://cdn.jsdelivr.net/npm/@multisynq/client@latest/bundled/multisynq-client.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            font-family: 'Courier New', monospace;
            color: white;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameWrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            width: 100%;
            box-sizing: border-box;
        }
        
        h1 {
            margin: 10px 0;
            font-size: 28px;
            flex-shrink: 0;
        }
        
        #gameContainer {
            background: #000;
            border: 3px solid #333;
            border-radius: 8px;
            position: relative;
            margin: 10px 0;
            /* Responsive container */
            width: 100%;
            max-width: 1200px;
            aspect-ratio: 16/9;
            flex: 1;
        }
        
        #gameCanvas {
            display: block;
            background: #000;
            width: 100%;
            height: 100%;
            /* Maintain pixel-perfect scaling */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        #ui {
            display: flex;
            gap: 20px;
            margin: 10px 0;
            font-size: 16px;
            flex-wrap: wrap;
            justify-content: center;
            flex-shrink: 0;
        }
        
        #playerList {
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            min-width: 300px;
            max-width: 100%;
            flex-shrink: 0;
        }
        
        .player-info {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        
        .player-local {
            background: rgba(0, 255, 0, 0.2);
            border-left: 3px solid #0f0;
        }
        
        .player-remote {
            background: rgba(255, 255, 0, 0.2);
            border-left: 3px solid #ff0;
        }
        
        #controls {
            text-align: center;
            margin: 10px 0;
            opacity: 0.7;
            max-width: 100%;
            padding: 0 20px;
            flex-shrink: 0;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            #ui {
                font-size: 14px;
                gap: 10px;
                margin: 5px 0;
            }
            
            #playerList {
                min-width: 250px;
                padding: 10px;
            }
            
            h1 {
                font-size: 20px;
                margin: 5px 0;
            }
            
            #controls {
                margin: 5px 0;
                padding: 0 10px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Background Music -->
    <audio id="backgroundMusic" loop>
        <source src="8-bit-retro-game-music-233964.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- Sound Effects -->
    <audio id="explosionSound" preload="auto">
        <source src="explosion.mp3" type="audio/mpeg">
    </audio>
    <audio id="powerupSound" preload="auto">
        <source src="powerup.mp3" type="audio/mpeg">
    </audio>
    <audio id="deathSound" preload="auto">
        <source src="dead_scream.mp3" type="audio/mpeg">
    </audio>
    
    <div id="gameWrapper">
        <h1>üéÆ Multiplayer Bomberman</h1>
        
        <div id="ui">
            <div>Lives: <span id="lives">3</span></div>
            <div>Bombs: <span id="bombs">1</span></div>
            <div>Fire Power: <span id="fire">1</span></div>
            <div id="gameStatus">Initializing...</div>
                            <div id="abilities" style="margin-top: 5px; font-size: 12px;">
                    <div id="shieldStatus" style="display: none; color: #00ffff;">üõ°Ô∏è Shield Active</div>
                    <div id="remoteStatus" style="display: none; color: #ff00ff;">üéÆ Remote Control Ready</div>
                    <div id="throwStatus" style="display: none; color: #ff8800;">üí£ Throw Bomb Active - Hold Space for distance</div>
                    <div id="speedStatus" style="display: none; color: #00ff00;">üí® Speed Boost Active</div>
                <div id="throwStrengthBar" style="display: none; margin-top: 5px;">
                    <div style="font-size: 10px; color: #ff8800; margin-bottom: 2px;">Throw Strength:</div>
                    <div style="width: 100px; height: 8px; background: #333; border: 1px solid #666; border-radius: 4px; overflow: hidden;">
                        <div id="throwStrengthFill" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff8800, #ff4400); transition: width 0.1s;"></div>
                    </div>
                    <div id="throwDistanceText" style="font-size: 9px; color: #ff8800; margin-top: 2px;">Distance: 1 tile</div>
                </div>
                <div style="margin-top: 5px; font-size: 10px; opacity: 0.8;">
                    <div>üíõ Bomb | üß° Fire | üíö Speed | üíô Shield | üíú Remote | üß° Throw</div>
                </div>
            </div>
            <div>üéµ <button id="musicToggle" style="background: #00ff88; color: #000; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Music: ON</button></div>
        </div>
        
        <div id="gameContainer">
            <canvas id="gameCanvas" width="1280" height="720"></canvas>
        </div>
        
        <div id="playerList">
            <div style="font-weight: bold; margin-bottom: 10px;">Players:</div>
            <div id="players">Waiting for players...</div>
        </div>
        
        <div id="controls">
            <strong>Controls:</strong> Arrow Keys or WASD to move ‚Ä¢ Spacebar to place bomb ‚Ä¢ Hold Spacebar to throw bomb ‚Ä¢ R key for remote detonation (max 2 bombs) ‚Ä¢ Share this URL to play with friends!
        </div>
    </div>

    <script>
        // Game constants - optimized for 16:9 resolution
        const TILE_SIZE = 32; // Slightly larger tiles for better visibility
        const GAME_WIDTH = 20; // Wider grid for 16:9
        const GAME_HEIGHT = 15; // Keep height the same
        const MOVE_SPEED = 130;
        const BOMB_TIMER = 3000; // 3 seconds in milliseconds
        const EXPLOSION_DURATION = 1000; // 1 second
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false; // Pixel art style
        
        // Game state
        let sprites = {};
        let spritesLoaded = 0;
        const totalSprites = 13;
        
        // Load all sprites - keeping original paths and structure
        function loadSprites() {
            const spriteList = [
                { name: 'wall-steel', path: 'sprites/wall-steel.png' },
                { name: 'brick-red', path: 'sprites/brick-red.png' },
                { name: 'door', path: 'sprites/door.png' },
                { name: 'kaboom', path: 'sprites/kaboom.png' },
                { name: 'bg', path: 'sprites/bg.png' },
                { name: 'wall-gold', path: 'sprites/wall-gold.png' },
                { name: 'brick-wood', path: 'sprites/brick-wood.png' },
                { name: 'bomberman', path: 'images/bombermon.png' },
                { name: 'bomb', path: 'sprites/bomb.png' },
                { name: 'explosion', path: 'sprites/explosion.png' },
                { name: 'powerup-bomb', path: 'sprites/powerup-bomb.png' },
                { name: 'powerup-fire', path: 'sprites/powerup-fire.png' },
                { name: 'powerup-speed', path: 'sprites/powerup-speed.png' }
            ];
            
            spriteList.forEach(sprite => {
                const img = new Image();
                img.onload = () => {
                    sprites[sprite.name] = img;
                    spritesLoaded++;
                    
                    if (spritesLoaded === totalSprites) {
                        console.log('All sprites loaded!');
                        startGame();
                    }
                };
                img.onerror = () => {
                    console.warn(`Failed to load sprite: ${sprite.name}`);
                    spritesLoaded++;
                    if (spritesLoaded === totalSprites) {
                        startGame();
                    }
                };
                img.src = sprite.path;
            });
        }
        
        // Animation frame data for Bomberman sprite (7x4 grid)
        const animations = {
            idleUp: { row: 0, frames: [0] },
            moveUp: { row: 0, frames: [1, 2, 3, 4, 5, 6] },
            idleRight: { row: 1, frames: [0] },
            moveRight: { row: 1, frames: [1, 2, 3, 4, 5, 6] },
            idleDown: { row: 2, frames: [0] },
            moveDown: { row: 2, frames: [1, 2, 3, 4, 5, 6] },
            idleLeft: { row: 3, frames: [0] },
            moveLeft: { row: 3, frames: [1, 2, 3, 4, 5, 6] }
        };
        
        // Bomb animation data (3 frames)
        const bombAnimation = {
            frames: [0, 1, 2],
            frameDuration: 150 // 150ms per frame - faster animation
        };
        
        // 16:9 optimized level map (20x15 tiles) - More strategic layout
        const LEVEL_MAP = [
            'aaaaaaaaaaaaaaaaaaaa',
            'a @ z z z z z z z z a',
            'a z a z a z a z a z a',
            'a z z z z z z z z z a', 
            'a z a z a z a z a z a',
            'a z z z z z z z z z a',
            'a z a z a z a z a z a',
            'a z z z z z z z z z a',
            'a z a z a z a z a z a',
            'a z z z z z z z z z a',
            'a z a z a z a z a z a',
            'a z z z z & z z z z a',
            'a z a z a z a z a z a',
            'a $ z z z * z z z # a',
            'aaaaaaaaaaaaaaaaaaaa',
        ];
        
        // LobbyRelayModel - communicates with lobby session
        class LobbyRelayModel extends Multisynq.Model {
            init() {
                this._lobbySessionId = null;
                this._gameSessionId = null;
                this._playerName = null;
                this._isHost = false;
                
                // Subscribe to lobby events
                this.subscribe(this.sessionId, "lobby-connect", this.connectToLobby);
                this.subscribe(this.sessionId, "game-status-update", this.updateLobbyStatus);
                
                console.log('LobbyRelayModel initialized');
            }
            
            connectToLobby(data) {
                this._lobbySessionId = data.lobbySessionId;
                this._gameSessionId = data.gameSessionId;
                this._playerName = data.playerName;
                this._isHost = data.isHost;
                
                console.log('LobbyRelay connected to lobby:', this._lobbySessionId);
                
                // Notify lobby that game has started
                this.publish(this._lobbySessionId, "game-started", {
                    gameSessionId: this._gameSessionId,
                    playerName: this._playerName,
                    isHost: this._isHost
                });
            }
            
            updateLobbyStatus(data) {
                if (this._lobbySessionId) {
                    this.publish(this._lobbySessionId, "game-status", {
                        gameSessionId: this._gameSessionId,
                        status: data.status,
                        playerCount: data.playerCount,
                        gameState: data.gameState
                    });
                }
            }
        }
        
        // Register the LobbyRelayModel
        if (typeof LobbyRelayModel.register === 'function') {
            LobbyRelayModel.register("LobbyRelayModel");
        } else {
            console.warn('LobbyRelayModel.register not available');
        }
        
        // LobbyRelayView - handles lobby communication
        class LobbyRelayView extends Multisynq.View {
            constructor(model) {
                super(model);
                this.model = model;
                this.setupSubscriptions();
            }
            
            setupSubscriptions() {
                this.subscribe(this.sessionId, "lobby-status", this.onLobbyStatus);
            }
            
            onLobbyStatus(data) {
                console.log('Received lobby status:', data);
                // Could update UI or handle lobby messages here
            }
            
            detach() {
                // Clean up when view is detached
                this.unsubscribeAll();
            }
        }
        
        // Register the LobbyRelayView
        if (typeof LobbyRelayView.register === 'function') {
            LobbyRelayView.register("LobbyRelayView");
        } else {
            console.warn('LobbyRelayView.register not available');
        }
        
        // MultiSynq Models
        class GameModel extends Multisynq.Model {
            init() {
                this.players = new Map();
                this.bombs = new Set();
                this.explosions = new Set();
                this.powerUps = new Set();
                this.gameStarted = false;
                this.gameOver = false;
                this.winner = null;
                
                // Initialize destructible blocks
                this.destructibleBlocks = new Set();
                LEVEL_MAP.forEach((row, y) => {
                    row.split('').forEach((cell, x) => {
                        if (cell === 'z') {
                            this.destructibleBlocks.add(`${x},${y}`);
                        }
                    });
                });
                
                // Create LobbyRelayModel for lobby communication
                LobbyRelayModel.create();
                
                // Subscribe to events
                this.subscribe(this.sessionId, "view-join", this.playerJoined);
                this.subscribe(this.sessionId, "view-exit", this.playerExited);
                this.subscribe(this.sessionId, "restart-game", this.restartGame);
                
                // Start main loop at 20fps for better performance
                this.mainLoop();
            }
            
            playerJoined(viewInfo) {
                // Handle different viewInfo formats - sometimes it's just the viewId string
                const viewId = typeof viewInfo === 'string' ? viewInfo : (viewInfo.viewId || viewInfo);
                
                if (!viewId) {
                    console.error('Invalid viewInfo received:', viewInfo);
                    return;
                }
                
                const playerId = this.players.size;
                
                // Spawn positions - optimized for 16:9 map (20x15)
                const spawnPositions = [
                    { x: TILE_SIZE, y: TILE_SIZE },                    // Top-left
                    { x: TILE_SIZE * 18, y: TILE_SIZE },              // Top-right
                    { x: TILE_SIZE, y: TILE_SIZE * 13 },              // Bottom-left
                    { x: TILE_SIZE * 18, y: TILE_SIZE * 13 }          // Bottom-right
                ];
                
                try {
                    const player = PlayerModel.create({
                        viewId: viewId,
                        playerId: playerId,
                        position: spawnPositions[playerId % 4]
                    });
                    
                    this.players.set(viewId, player);
                } catch (error) {
                    console.error('Failed to create player:', error);
                    return; // Don't continue if player creation failed
                }
                
                if (this.players.size >= 2 && !this.gameStarted) {
                    this.gameStarted = true;
                    this.publish(this.sessionId, "game-started", {});
                }
                
                this.updatePlayerList();
            }
            
            playerExited(viewInfo) {
                // Handle different viewInfo formats
                const viewId = typeof viewInfo === 'string' ? viewInfo : (viewInfo.viewId || viewInfo);
                
                if (!viewId) {
                    console.error('Invalid viewInfo received on exit:', viewInfo);
                    return;
                }
                
                const player = this.players.get(viewId);
                if (player) {
                    player.destroy();
                    this.players.delete(viewId);
                    this.updatePlayerList();
                }
            }
            
            updatePlayerList() {
                const playerData = Array.from(this.players.values()).map(p => ({
                    viewId: p.viewId,
                    playerId: p.playerId,
                    lives: p.lives,
                    isAlive: p.isAlive
                }));
                this.publish(this.sessionId, "player-list-updated", { players: playerData });
                
                // Debug: Log current state
                console.log(`Game state: ${this.destructibleBlocks.size} destructible blocks, ${this.powerUps.size} power-ups`);
            }
            
            restartGame() {
                this.gameOver = false;
                this.gameStarted = false;
                this.winner = null;
                this.bombs.clear();
                this.explosions.clear();
                this.powerUps.clear();
                
                // Reset destructible blocks
                this.destructibleBlocks.clear();
                LEVEL_MAP.forEach((row, y) => {
                    row.split('').forEach((cell, x) => {
                        if (cell === 'z') {
                            this.destructibleBlocks.add(`${x},${y}`);
                        }
                    });
                });
                
                // Reset players
                const spawnPositions = [
                    { x: TILE_SIZE, y: TILE_SIZE },
                    { x: TILE_SIZE * 13, y: TILE_SIZE },
                    { x: TILE_SIZE, y: TILE_SIZE * 13 },
                    { x: TILE_SIZE * 13, y: TILE_SIZE * 13 }
                ];
                
                let playerIndex = 0;
                for (const player of this.players.values()) {
                    player.reset(spawnPositions[playerIndex % 4]);
                    playerIndex++;
                }
                
                if (this.players.size >= 2) {
                    this.gameStarted = true;
                    this.publish(this.sessionId, "game-started", {});
                }
                
                this.updatePlayerList();
            }
            
            mainLoop() {
                if (!this.gameOver && this.gameStarted) {
                    // Update all entities
                    for (const player of this.players.values()) {
                        if (player && player.update) {
                            player.update();
                        }
                    }
                    
                    for (const bomb of this.bombs) {
                        if (bomb && bomb.update) {
                            bomb.update();
                        }
                    }
                    
                    for (const explosion of this.explosions) {
                        if (explosion && explosion.update) {
                            explosion.update();
                        }
                    }
                    
                    // Check win condition
                    this.checkWinCondition();
                }
                
                // Run at 20fps for better performance (50ms intervals)
                this.future(50).mainLoop();
            }
            
            checkWinCondition() {
                const alivePlayers = Array.from(this.players.values()).filter(p => p.isAlive);
                
                if (alivePlayers.length <= 1 && this.players.size > 1) {
                    this.gameOver = true;
                    this.winner = alivePlayers.length === 1 ? alivePlayers[0].viewId : null;
                    const winnerName = this.winner ? `Player ${alivePlayers[0].playerId + 1}` : "Draw";
                    this.publish(this.sessionId, "game-over", { winner: this.winner, winnerName });
                }
            }
            
            isValidPosition(pos, excludePlayer = null) {
                const gridX = Math.round(pos.x / TILE_SIZE);
                const gridY = Math.round(pos.y / TILE_SIZE);
                
                if (gridX < 0 || gridY < 0 || gridX >= GAME_WIDTH || gridY >= GAME_HEIGHT) {
                    return false;
                }
                
                const cell = LEVEL_MAP[gridY].charAt(gridX);
                if (cell === 'a') return false; // Steel wall
                if (cell === 'z' && this.destructibleBlocks.has(`${gridX},${gridY}`)) {
                    return false; // Brick wall (only if it still exists)
                }
                // If cell is 'z' but block doesn't exist in destructibleBlocks, it's walkable (green tile)
                
                // Check for bombs
                for (const bomb of this.bombs) {
                    if (Math.abs(bomb.pos.x - pos.x) < TILE_SIZE/2 && 
                        Math.abs(bomb.pos.y - pos.y) < TILE_SIZE/2) {
                        return false;
                    }
                }
                
                return true;
            }
            
            snapToGrid(pos) {
                return {
                    x: Math.round(pos.x / TILE_SIZE) * TILE_SIZE,
                    y: Math.round(pos.y / TILE_SIZE) * TILE_SIZE
                };
            }
        }
        GameModel.register("GameModel");
        
        class PlayerModel extends Multisynq.Model {
            init({ viewId, playerId, position }) {
                // Validate input parameters
                if (!viewId || typeof viewId !== 'string') {
                    console.error('PlayerModel: Invalid viewId provided:', viewId);
                    throw new Error('PlayerModel requires valid viewId');
                }
                
                if (playerId === undefined || playerId === null) {
                    console.error('PlayerModel: Invalid playerId provided:', playerId);
                    throw new Error('PlayerModel requires valid playerId');
                }
                
                if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {
                    console.error('PlayerModel: Invalid position provided:', position);
                    throw new Error('PlayerModel requires valid position');
                }
                
                this.viewId = viewId;
                this.playerId = playerId;
                this.pos = position;
                this.lives = 3;
                this.bombCount = 1;
                this.firePower = 1;
                this.moveSpeed = MOVE_SPEED; // Initialize move speed
                this.isAlive = true;
                this.isMoving = false;
                this.targetPos = null;
                this.lastDirection = 'down';
                this.currentAnimation = 'idleDown';
                this.animationFrame = 0;
                this.animationTimer = 0;
                this.moveProgress = 0;
                this.lastMoveTime = 0;
                this.lastBombTime = 0;
                
                // Bomb holding mechanics
                this.isHoldingBomb = false;
                this.heldBomb = null;
                this.bombHoldStartTime = 0;
                this.bombHoldDuration = 2500; // 2.5 seconds in milliseconds
                this.spacePressed = false;
                this.spacePressStartTime = 0;
                
                // Special abilities with timers
                this.hasShield = false;
                this.shieldDuration = 0;
                this.hasRemoteControl = false;
                this.remoteControlDuration = 0;
                this.hasThrowBomb = false;
                this.throwBombDuration = 0;
                this.speedBoostDuration = 0;
                this.remoteBombs = []; // Track remote bombs (max 2)
                
                console.log(`Player ${this.playerId} initialized with shield: ${this.hasShield}, duration: ${this.shieldDuration}`);
                
                // Subscribe to player-specific events
                try {
                    this.subscribe(viewId, "move", this.handleMove);
                    this.subscribe(viewId, "place-bomb", this.placeBomb);
                    this.subscribe(viewId, "start-hold-bomb", this.startHoldingBomb);
                    this.subscribe(viewId, "throw-held-bomb", this.throwBomb);
                    this.subscribe(viewId, "detonate-remote", this.detonateRemoteBombs);
                    console.log(`Player ${playerId} (${viewId}) initialized successfully`);
                } catch (error) {
                    console.error('Failed to subscribe to player events:', error);
                    throw error;
                }
            }
            
            get game() {
                return this.wellKnownModel("modelRoot");
            }
            
            reset(position) {
                this.pos = position;
                this.lives = 3;
                this.bombCount = 1;
                this.firePower = 1;
                this.moveSpeed = MOVE_SPEED; // Reset move speed
                this.isAlive = true;
                this.isMoving = false;
                this.targetPos = null;
                this.lastDirection = 'down';
                this.currentAnimation = 'idleDown';
                this.moveProgress = 0;
                
                // Reset abilities with timers
                this.hasShield = false;
                this.shieldDuration = 0;
                this.hasRemoteControl = false;
                this.remoteControlDuration = 0;
                this.hasThrowBomb = false;
                this.throwBombDuration = 0;
                this.speedBoostDuration = 0;
                this.remoteBombs = []; // Clear remote bombs
                
                console.log(`Player ${this.playerId} reset - shield: ${this.hasShield}, duration: ${this.shieldDuration}`);
            }
            
            handleMove(data) {
                if (!this.isAlive || this.isMoving || this.game.gameOver) return;
                
                const { direction } = data;
                const now = this.now();
                
                // Reduced rate limiting for faster response
                if (now - this.lastMoveTime < 120) return; // Reduced from 160ms to 120ms
                
                const targetPos = this.calculateTargetPosition(direction);
                
                if (this.game.isValidPosition(targetPos, this)) {
                    this.startMovement(direction, targetPos);
                    this.lastMoveTime = now;
                } else {
                    // Allow direction change even if movement isn't possible
                    this.lastDirection = direction;
                    this.currentAnimation = `idle${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
                }
            }
            
            calculateTargetPosition(direction) {
                switch(direction) {
                    case 'left': return { x: this.pos.x - TILE_SIZE, y: this.pos.y };
                    case 'right': return { x: this.pos.x + TILE_SIZE, y: this.pos.y };
                    case 'up': return { x: this.pos.x, y: this.pos.y - TILE_SIZE };
                    case 'down': return { x: this.pos.x, y: this.pos.y + TILE_SIZE };
                    default: return this.pos;
                }
            }
            
            startMovement(direction, targetPos) {
                this.isMoving = true;
                this.targetPos = targetPos;
                this.lastDirection = direction;
                this.currentAnimation = `move${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
                this.moveProgress = 0;
                this.interpolateMovement();
            }
            
            interpolateMovement() {
                if (!this.isMoving) return;
                
                // Calculate speed factor based on moveSpeed
                const baseSpeed = 0.18;
                const speedFactor = this.moveSpeed / MOVE_SPEED;
                const progressIncrement = baseSpeed * speedFactor;
                
                this.moveProgress += progressIncrement;
                
                if (this.moveProgress >= 1.0) {
                    this.pos = this.targetPos;
                    this.isMoving = false;
                    this.moveProgress = 0;
                    this.currentAnimation = `idle${this.lastDirection.charAt(0).toUpperCase() + this.lastDirection.slice(1)}`;
                } else {
                    // Adjust timing based on speed
                    const baseTiming = 14;
                    const timingFactor = 1 / speedFactor;
                    const nextUpdate = Math.max(8, Math.min(20, baseTiming * timingFactor));
                    this.future(nextUpdate).interpolateMovement();
                }
            }
            
            getCurrentPosition() {
                if (!this.isMoving || !this.targetPos) return this.pos;
                
                return {
                    x: this.pos.x + (this.targetPos.x - this.pos.x) * this.moveProgress,
                    y: this.pos.y + (this.targetPos.y - this.pos.y) * this.moveProgress
                };
            }
            
            placeBomb(data = {}) {
                if (!this.isAlive || this.game.gameOver) return;
                
                const now = this.now();
                if (now - this.lastBombTime < 500) return;
                
                // If already holding a bomb, throw it
                if (this.isHoldingBomb && this.heldBomb) {
                    this.throwBomb();
                    return;
                }
                
                // If player has throw bomb ability, automatically throw with dynamic distance
                if (this.hasThrowBomb) {
                    // Pass hold duration for throw distance calculation
                    const holdDuration = data.holdDuration || 0;
                    this.autoThrowBomb(holdDuration);
                    return;
                }
                
                const bombPos = this.game.snapToGrid(this.pos);
                
                // Check if bomb already exists at position
                for (const bomb of this.game.bombs) {
                    if (Math.abs(bomb.pos.x - bombPos.x) < TILE_SIZE/2 && 
                        Math.abs(bomb.pos.y - bombPos.y) < TILE_SIZE/2) {
                        return;
                    }
                }
                
                // Handle remote bombs if player has remote control
                if (this.hasRemoteControl) {
                    this.placeRemoteBomb(bombPos);
                } else {
                    // Place normal bomb
                    BombModel.create({
                        position: bombPos,
                        owner: this,
                        firePower: this.firePower
                    });
                }
                
                this.lastBombTime = now;
            }
            
            autoThrowBomb(holdDuration = 0) {
                const now = this.now();
                
                // Calculate throw distance based on hold time (0.5s to 2.5s)
                const holdTime = Math.min(holdDuration, 2500);
                const minDistance = 1; // Minimum 1 tile
                const maxDistance = 8; // Maximum 8 tiles
                const distance = Math.floor(minDistance + (holdTime / 2500) * (maxDistance - minDistance));
                
                // Calculate throw direction based on last movement direction
                let throwPos = { ...this.pos };
                
                switch(this.lastDirection) {
                    case 'up':
                        throwPos.y -= TILE_SIZE * distance;
                        break;
                    case 'down':
                        throwPos.y += TILE_SIZE * distance;
                        break;
                    case 'left':
                        throwPos.x -= TILE_SIZE * distance;
                        break;
                    case 'right':
                        throwPos.x += TILE_SIZE * distance;
                        break;
                }
                
                // Find the closest valid position for the throw
                const validThrowPos = this.findValidThrowPosition(throwPos);
                
                // Create and place the bomb at the valid throw position
                if (this.hasRemoteControl) {
                    this.placeRemoteBomb(validThrowPos);
                } else {
                    BombModel.create({
                        position: validThrowPos,
                        owner: this,
                        firePower: this.firePower
                    });
                }
                
                console.log(`Player ${this.playerId} auto-threw bomb to (${validThrowPos.x}, ${validThrowPos.y}) - distance: ${distance} tiles`);
                
                // Publish to view for visual feedback
                this.publish(this.viewId, "bomb-auto-thrown", {
                    playerId: this.playerId,
                    throwPosition: validThrowPos,
                    distance: distance
                });
                
                this.lastBombTime = now;
            }
            
            findValidThrowPosition(targetPos) {
                const startPos = this.game.snapToGrid(this.pos);
                const direction = {
                    x: Math.sign(targetPos.x - startPos.x),
                    y: Math.sign(targetPos.y - startPos.y)
                };
                
                // Check each position from start to target, find the last valid one
                let lastValidPos = startPos;
                
                for (let i = 1; i <= Math.max(Math.abs(targetPos.x - startPos.x), Math.abs(targetPos.y - startPos.y)) / TILE_SIZE; i++) {
                    const checkPos = {
                        x: startPos.x + (direction.x * TILE_SIZE * i),
                        y: startPos.y + (direction.y * TILE_SIZE * i)
                    };
                    
                    // Snap to grid
                    const gridPos = this.game.snapToGrid(checkPos);
                    
                    // Check if position is valid
                    if (this.game.isValidPosition(gridPos, this)) {
                        lastValidPos = gridPos;
                    } else {
                        // Found a wall/block, stop here
                        break;
                    }
                }
                
                return lastValidPos;
            }
            
            placeRemoteBomb(bombPos) {
                // Remove oldest remote bomb if we have 2 already
                if (this.remoteBombs.length >= 2) {
                    const oldestBomb = this.remoteBombs.shift();
                    if (oldestBomb && this.game.bombs.has(oldestBomb)) {
                        this.game.bombs.delete(oldestBomb);
                        oldestBomb.destroy();
                        console.log(`Player ${this.playerId} removed oldest remote bomb to make room`);
                    }
                }
                
                // Create new remote bomb
                const remoteBomb = BombModel.create({
                    position: bombPos,
                    owner: this,
                    firePower: this.firePower,
                    isRemote: true
                });
                
                this.remoteBombs.push(remoteBomb);
                console.log(`Player ${this.playerId} placed remote bomb (${this.remoteBombs.length}/2)`);
            }
            
            startHoldingBomb() {
                if (!this.isAlive || this.game.gameOver || this.isHoldingBomb) return;
                
                const now = this.now();
                if (now - this.lastBombTime < 500) return;
                
                // Check remote bomb limit if player has remote control
                if (this.hasRemoteControl && this.remoteBombs.length >= 2) {
                    console.log(`Player ${this.playerId} cannot hold bomb - remote bomb limit reached (${this.remoteBombs.length}/2)`);
                    return;
                }
                
                // Create a bomb that the player will hold
                this.heldBomb = BombModel.create({
                    position: this.pos, // Start at player position
                    owner: this,
                    firePower: this.firePower,
                    isHeld: true, // Mark as held bomb
                    isRemote: this.hasRemoteControl // Mark as remote if player has remote control
                });
                
                this.isHoldingBomb = true;
                this.bombHoldStartTime = now;
                this.lastBombTime = now;
                
                console.log(`Player ${this.playerId} started holding ${this.hasRemoteControl ? 'remote' : 'normal'} bomb`);
                
                // Publish to view for visual feedback
                this.publish(this.viewId, "bomb-holding-started", {
                    playerId: this.playerId,
                    holdStartTime: this.bombHoldStartTime,
                    isRemote: this.hasRemoteControl
                });
            }
            
            throwBomb() {
                if (!this.isAlive || !this.isHoldingBomb || !this.heldBomb) return;
                
                const now = this.now();
                

                
                // Calculate throw direction based on last movement direction
                let throwPos = { ...this.pos };
                
                switch(this.lastDirection) {
                    case 'up':
                        throwPos.y -= TILE_SIZE * 3; // Throw 3 tiles up
                        break;
                    case 'down':
                        throwPos.y += TILE_SIZE * 3; // Throw 3 tiles down
                        break;
                    case 'left':
                        throwPos.x -= TILE_SIZE * 3; // Throw 3 tiles left
                        break;
                    case 'right':
                        throwPos.x += TILE_SIZE * 3; // Throw 3 tiles right
                        break;
                }
                
                // Snap to grid
                throwPos = this.game.snapToGrid(throwPos);
                
                // Check if position is valid
                if (this.game.isValidPosition(throwPos, this)) {
                    // Move the held bomb to the throw position
                    this.heldBomb.pos = throwPos;
                    this.heldBomb.isHeld = false; // No longer held
                    
                    // Handle remote bombs differently
                    if (this.heldBomb.isRemote) {
                        // Check if we can add another remote bomb
                        if (this.remoteBombs.length >= 2) {
                            // Remove oldest remote bomb to make room
                            const oldestBomb = this.remoteBombs.shift();
                            if (oldestBomb && this.game.bombs.has(oldestBomb)) {
                                this.game.bombs.delete(oldestBomb);
                                oldestBomb.destroy();
                                console.log(`Player ${this.playerId} removed oldest remote bomb to make room`);
                            }
                        }
                        
                        // Add to remote bombs array
                        this.remoteBombs.push(this.heldBomb);
                        this.game.bombs.add(this.heldBomb);
                        this.heldBomb.startAnimation(); // Start the animation (no countdown for remote bombs)
                        console.log(`Player ${this.playerId} threw remote bomb (${this.remoteBombs.length}/2)`);
                    } else {
                        // Add to game bombs set and start countdown for normal bombs
                        this.game.bombs.add(this.heldBomb);
                        this.heldBomb.countdown(); // Start the explosion timer
                        this.heldBomb.startAnimation(); // Start the animation
                    }
                    
                    console.log(`Player ${this.playerId} threw bomb to (${throwPos.x}, ${throwPos.y})`);
                    
                    // Publish to view for visual feedback
                    this.publish(this.viewId, "bomb-thrown", {
                        playerId: this.playerId,
                        throwPosition: throwPos,
                        holdDuration: now - this.bombHoldStartTime
                    });
                } else {
                    // If throw position is invalid, place at current position
                    this.heldBomb.pos = this.game.snapToGrid(this.pos);
                    this.heldBomb.isHeld = false;
                    
                    // Handle remote bombs differently
                    if (this.heldBomb.isRemote) {
                        // Check if we can add another remote bomb
                        if (this.remoteBombs.length >= 2) {
                            // Remove oldest remote bomb to make room
                            const oldestBomb = this.remoteBombs.shift();
                            if (oldestBomb && this.game.bombs.has(oldestBomb)) {
                                this.game.bombs.delete(oldestBomb);
                                oldestBomb.destroy();
                                console.log(`Player ${this.playerId} removed oldest remote bomb to make room`);
                            }
                        }
                        
                        // Add to remote bombs array
                        this.remoteBombs.push(this.heldBomb);
                        this.game.bombs.add(this.heldBomb);
                        this.heldBomb.startAnimation(); // Start the animation (no countdown for remote bombs)
                        console.log(`Player ${this.playerId} placed held remote bomb at current position (${this.remoteBombs.length}/2)`);
                    } else {
                        // Add to game bombs set and start countdown for normal bombs
                        this.game.bombs.add(this.heldBomb);
                        this.heldBomb.countdown(); // Start the explosion timer
                        this.heldBomb.startAnimation(); // Start the animation
                        console.log(`Player ${this.playerId} placed held bomb at current position`);
                    }
                }
                
                // Reset holding state
                this.isHoldingBomb = false;
                this.heldBomb = null;
                this.bombHoldStartTime = 0;
            }
            
            updateHeldBomb() {
                if (!this.isHoldingBomb || !this.heldBomb) return;
                
                // Update held bomb position to follow player
                this.heldBomb.pos = { ...this.pos };
                
                // Disable death mechanism for held bombs - they should only explode when placed
                // The bomb timer will start when the bomb is placed on the ground
            }
            
            takeDamage() {
                if (!this.isAlive) return;
                
                // Shield protection
                if (this.hasShield) {
                    console.log(`Player ${this.playerId} blocked damage with shield!`);
                    this.hasShield = false;
                    this.shieldDuration = 0;
                    
                    // Publish shield block event for UI feedback
                    this.publish(this.viewId, "shield-blocked", {
                        playerId: this.playerId
                    });
                    
                    return; // Shield absorbs the damage
                } else {
                    console.log(`Player ${this.playerId} taking damage (no shield)`);
                }
                
                this.lives--;
                
                if (this.lives <= 0) {
                    this.isAlive = false;
                    // Play death sound when player dies
                    playDeathSound();
                } else {
                    // Respawn at spawn position
                    const spawnPositions = [
                        { x: TILE_SIZE, y: TILE_SIZE },
                        { x: TILE_SIZE * 13, y: TILE_SIZE },
                        { x: TILE_SIZE, y: TILE_SIZE * 13 },
                        { x: TILE_SIZE * 13, y: TILE_SIZE * 13 }
                    ];
                    this.pos = spawnPositions[this.playerId % 4];
                    this.isMoving = false;
                    this.targetPos = null;
                }
                
                this.publish(this.viewId, "player-damaged", {
                    lives: this.lives,
                    isAlive: this.isAlive
                });
            }
            
            update() {
                if (!this.isAlive) return;
                
                // Update animation at 20fps instead of 60fps
                this.animationTimer += 50;
                if (this.animationTimer > 150) { // Animation speed
                    this.animationTimer = 0;
                    const animData = animations[this.currentAnimation];
                    if (animData && animData.frames.length > 1) {
                        this.animationFrame = (this.animationFrame + 1) % animData.frames.length;
                    }
                }
                
                // Update shield duration
                if (this.hasShield && this.shieldDuration > 0) {
                    this.shieldDuration -= 100; // Reduce by 100ms each update
                    if (this.shieldDuration <= 0) {
                        this.hasShield = false;
                        console.log(`Player ${this.playerId} shield expired`);
                    }
                }
                
                // Update speed boost duration
                if (this.speedBoostDuration > 0) {
                    this.speedBoostDuration -= 100; // Reduce by 100ms each update
                    if (this.speedBoostDuration <= 0) {
                        this.moveSpeed = MOVE_SPEED; // Reset to base speed
                        console.log(`Player ${this.playerId} speed boost expired`);
                    }
                }
                
                // Update remote control duration
                if (this.hasRemoteControl && this.remoteControlDuration > 0) {
                    this.remoteControlDuration -= 100; // Reduce by 100ms each update
                    if (this.remoteControlDuration <= 0) {
                        this.hasRemoteControl = false;
                        // Clear any existing remote bombs
                        for (const bomb of this.remoteBombs) {
                            if (bomb && this.game.bombs.has(bomb)) {
                                bomb.explode();
                            }
                        }
                        this.remoteBombs = [];
                        console.log(`Player ${this.playerId} remote control expired`);
                    }
                }
                
                // Update throw bomb duration
                if (this.hasThrowBomb && this.throwBombDuration > 0) {
                    this.throwBombDuration -= 100; // Reduce by 100ms each update
                    if (this.throwBombDuration <= 0) {
                        this.hasThrowBomb = false;
                        console.log(`Player ${this.playerId} throw bomb ability expired`);
                    }
                }
                
                // Update held bomb
                this.updateHeldBomb();
                
                // Check for power-up collection every update
                this.checkPowerUpCollection();
            }
            
            checkPowerUpCollection() {
                if (!this.isAlive) return;
                
                const currentPos = this.getCurrentPosition();
                const playerGridX = Math.round(currentPos.x / TILE_SIZE);
                const playerGridY = Math.round(currentPos.y / TILE_SIZE);
                
                // Create array copy to safely iterate while modifying
                const powerUpsArray = Array.from(this.game.powerUps);
                
                for (const powerUp of powerUpsArray) {
                    // Check if power-up still exists (might have been collected by another player)
                    if (!this.game.powerUps.has(powerUp)) continue;
                    
                    const powerUpGridX = Math.round(powerUp.pos.x / TILE_SIZE);
                    const powerUpGridY = Math.round(powerUp.pos.y / TILE_SIZE);
                    
                    // Use grid-based collision detection for more reliable collection
                    if (playerGridX === powerUpGridX && playerGridY === powerUpGridY) {
                        powerUp.collect(this);
                        break; // Only collect one power-up per update
                    }
                }
            }
            
            detonateRemoteBombs() {
                if (!this.hasRemoteControl) {
                    console.log(`Player ${this.playerId} tried to detonate but has no remote control`);
                    return;
                }
                
                console.log(`Player ${this.playerId} detonating remote bombs...`);
                
                // Only detonate remote bombs
                let bombCount = 0;
                for (const bomb of this.remoteBombs) {
                    if (bomb && this.game.bombs.has(bomb)) {
                        bomb.explode();
                        bombCount++;
                    }
                }
                
                // Clear remote bombs array
                this.remoteBombs = [];
                
                // Remove remote control ability after use
                this.hasRemoteControl = false;
                console.log(`Player ${this.playerId} detonated ${bombCount} remote bombs`);
            }
        }
        PlayerModel.register("PlayerModel");
        
        class BombModel extends Multisynq.Model {
            init({ position, owner, firePower, isHeld = false, isRemote = false }) {
                this.pos = position;
                this.owner = owner;
                this.firePower = firePower;
                this.isHeld = isHeld;
                this.isRemote = isRemote;
                this.timer = BOMB_TIMER;
                this.animationFrame = 0;
                this.animationTimer = 0;
                
                // Only add to game bombs if not held
                if (!this.isHeld) {
                    this.game.bombs.add(this);
                    
                    // Only start countdown for non-remote bombs
                    if (!this.isRemote) {
                        this.countdown();
                    }
                    
                    this.startAnimation();
                }
            }
            
            get game() {
                return this.wellKnownModel("modelRoot");
            }
            
            countdown() {
                this.timer -= 100;
                
                if (this.timer <= 0) {
                    this.explode();
                } else {
                    this.future(100).countdown();
                }
            }
            
            startAnimation() {
                this.updateAnimation();
            }
            
            updateAnimation() {
                // Update bomb animation using time-based frame cycling
                this.animationTimer += bombAnimation.frameDuration;
                this.animationFrame = (this.animationFrame + 1) % bombAnimation.frames.length;
                
                // Schedule next animation update
                this.future(bombAnimation.frameDuration).updateAnimation();
            }
            
            update() {
                // Update bomb animation using time-based frame cycling
                this.animationTimer += 50; // Assuming 20fps (50ms per frame)
                if (this.animationTimer > bombAnimation.frameDuration) {
                    this.animationTimer = 0;
                    this.animationFrame = (this.animationFrame + 1) % bombAnimation.frames.length;
                }
            }
            
            explode() {
                this.game.bombs.delete(this);
                
                // Play explosion sound
                playExplosionSound();
                
                const explosionPositions = this.calculateExplosionPattern();
                
                for (const pos of explosionPositions) {
                    ExplosionModel.create({ position: pos });
                    
                    // Destroy bricks
                    const gridX = Math.round(pos.x / TILE_SIZE);
                    const gridY = Math.round(pos.y / TILE_SIZE);
                    const blockKey = `${gridX},${gridY}`;
                    
                    if (this.game.destructibleBlocks.has(blockKey)) {
                        console.log(`Destroying block at (${gridX}, ${gridY})`);
                        this.game.destructibleBlocks.delete(blockKey);
                        console.log(`Remaining blocks: ${this.game.destructibleBlocks.size}`);
                        
                        // Spawn power-up chance (30% chance)
                        const spawnChance = this.random();
                        if (spawnChance < 0.3) {
                            PowerUpModel.create({ position: { x: gridX * TILE_SIZE, y: gridY * TILE_SIZE } });
                        }
                    } else {
                        console.log(`Block at (${gridX}, ${gridY}) was already destroyed or doesn't exist`);
                    }
                    
                    // Damage players
                    for (const player of this.game.players.values()) {
                        const playerPos = player.getCurrentPosition();
                        if (Math.abs(playerPos.x - pos.x) < TILE_SIZE/2 &&
                            Math.abs(playerPos.y - pos.y) < TILE_SIZE/2) {
                            console.log(`Explosion at (${pos.x}, ${pos.y}) hitting player ${player.playerId} at (${playerPos.x}, ${playerPos.y})`);
                            console.log(`Player ${player.playerId} has shield: ${player.hasShield}`);
                            player.takeDamage();
                        }
                    }
                }
                
                this.destroy();
            }
            
            calculateExplosionPattern() {
                const positions = [this.pos];
                const directions = [
                    { x: 0, y: -1 }, // up
                    { x: 0, y: 1 },  // down
                    { x: -1, y: 0 }, // left
                    { x: 1, y: 0 }   // right
                ];
                
                directions.forEach(dir => {
                    for (let i = 1; i <= this.firePower; i++) {
                        const explosionPos = {
                            x: this.pos.x + (dir.x * TILE_SIZE * i),
                            y: this.pos.y + (dir.y * TILE_SIZE * i)
                        };
                        
                        const gridX = Math.round(explosionPos.x / TILE_SIZE);
                        const gridY = Math.round(explosionPos.y / TILE_SIZE);
                        
                        if (gridX < 0 || gridY < 0 || gridX >= GAME_WIDTH || gridY >= GAME_HEIGHT) {
                            break;
                        }
                        
                        const cell = LEVEL_MAP[gridY].charAt(gridX);
                        
                        if (cell === 'a') break; // Steel wall stops explosion
                        
                        positions.push(explosionPos);
                        
                        if (cell === 'z' && this.game.destructibleBlocks.has(`${gridX},${gridY}`)) {
                            break; // Brick wall stops explosion after being destroyed
                        }
                    }
                });
                
                return positions;
            }
        }
        BombModel.register("BombModel");
        
        class ExplosionModel extends Multisynq.Model {
            init({ position }) {
                this.pos = position;
                this.duration = EXPLOSION_DURATION;
                this.timeLeft = this.duration;
                
                this.game.explosions.add(this);
                this.countdown();
            }
            
            get game() {
                return this.wellKnownModel("modelRoot");
            }
            
            countdown() {
                this.timeLeft -= 100;
                
                if (this.timeLeft <= 0) {
                    this.game.explosions.delete(this);
                    this.destroy();
                } else {
                    this.future(100).countdown();
                }
            }
            
            update() {
                // Explosion updates
            }
        }
        ExplosionModel.register("ExplosionModel");
        
        class PowerUpModel extends Multisynq.Model {
            init({ position }) {
                this.pos = position;
                const types = ['bomb', 'fire', 'speed', 'shield', 'remote', 'throw'];
                this.type = types[Math.floor(this.random() * types.length)];
                
                this.game.powerUps.add(this);
            }
            
            get game() {
                return this.wellKnownModel("modelRoot");
            }
            
            collect(player) {
                // Play powerup sound
                playPowerupSound();
                
                console.log(`Player ${player.playerId} collected ${this.type} powerup`);
                
                switch(this.type) {
                    case 'bomb':
                        player.bombCount++;
                        console.log(`Player ${player.playerId} bomb count: ${player.bombCount}`);
                        break;
                    case 'fire':
                        player.firePower++;
                        console.log(`Player ${player.playerId} fire power: ${player.firePower}`);
                        break;
                    case 'speed':
                        player.moveSpeed = Math.min(player.moveSpeed + 20, 200);
                        player.speedBoostDuration = 15000; // 15 seconds
                        console.log(`Player ${player.playerId} got speed boost for 15 seconds`);
                        break;
                    case 'shield':
                        player.hasShield = true;
                        player.shieldDuration = 12000; // 12 seconds
                        console.log(`Player ${player.playerId} got shield for 12 seconds`);
                        console.log(`Player ${player.playerId} shield status: ${player.hasShield}, duration: ${player.shieldDuration}`);
                        break;
                    case 'remote':
                        player.hasRemoteControl = true;
                        player.remoteControlDuration = 20000; // 20 seconds
                        console.log(`Player ${player.playerId} got remote control for 20 seconds`);
                        break;
                    case 'throw':
                        player.hasThrowBomb = true;
                        player.throwBombDuration = 18000; // 18 seconds
                        console.log(`Player ${player.playerId} got throw bomb ability for 18 seconds`);
                        break;
                }
                
                // Publish to player's view
                player.publish(player.viewId, "powerup-collected", {
                    type: this.type,
                    playerId: player.playerId,
                    bombCount: player.bombCount,
                    firePower: player.firePower,
                    position: { x: this.pos.x, y: this.pos.y }
                });
                
                // Also publish globally for visual feedback
                this.game.publish(this.game.sessionId, "powerup-collected-global", {
                    type: this.type,
                    playerId: player.playerId,
                    position: { x: this.pos.x, y: this.pos.y }
                });
                
                // Remove from game state
                this.game.powerUps.delete(this);
                this.destroy();
            }
        }
        PowerUpModel.register("PowerUpModel");
        
        // View class for rendering
        class GameView extends Multisynq.View {
            constructor(model) {
                super(model);
                this.model = model;
                this.setupInput();
                this.setupUI();
                
                // Create LobbyRelayView for lobby communication
                this.lobbyRelay = new LobbyRelayView(this.wellKnownModel("lobbyRelay"));
                
                // Add view-side animation smoothing
                this.smoothing = new WeakMap();
                
                this.subscribe(this.sessionId, "game-started", this.onGameStarted);
                this.subscribe(this.sessionId, "game-over", this.onGameOver);
                this.subscribe(this.sessionId, "player-list-updated", this.onPlayerListUpdated);
                this.subscribe(this.sessionId, "powerup-collected-global", this.onPowerUpCollectedGlobal);
                this.subscribe(this.viewId, "player-damaged", this.onPlayerDamaged);
                this.subscribe(this.viewId, "powerup-collected", this.onPowerUpCollected);
                this.subscribe(this.viewId, "bomb-holding-started", this.onBombHoldingStarted);
                this.subscribe(this.viewId, "bomb-thrown", this.onBombThrown);
                this.subscribe(this.viewId, "bomb-auto-thrown", this.onBombAutoThrown);
                this.subscribe(this.viewId, "shield-blocked", this.onShieldBlocked);
                this.subscribe(this.viewId, "remote-bomb-limit-reached", this.onRemoteBombLimitReached);
                
                this.render();
            }
            
            // Add view-side animation smoothing
            smoothPos(obj) {
                if (!this.smoothing.has(obj)) {
                    this.smoothing.set(obj, { x: obj.pos.x, y: obj.pos.y });
                }
                const smoothed = this.smoothing.get(obj);
                const dx = obj.pos.x - smoothed.x;
                const dy = obj.pos.y - smoothed.y;
                
                // If distance is large, don't smooth but jump to new position
                if (Math.abs(dx) < 50) smoothed.x += dx * 0.3; else smoothed.x = obj.pos.x;
                if (Math.abs(dy) < 50) smoothed.y += dy * 0.3; else smoothed.y = obj.pos.y;
                
                return smoothed;
            }
            
            smoothPlayerPos(player) {
                if (!this.smoothing.has(player)) {
                    this.smoothing.set(player, { x: player.pos.x, y: player.pos.y });
                }
                const smoothed = this.smoothing.get(player);
                const currentPos = player.getCurrentPosition();
                const dx = currentPos.x - smoothed.x;
                const dy = currentPos.y - smoothed.y;
                
                // More responsive smoothing for local player
                const isLocalPlayer = player.viewId === this.viewId;
                const smoothingFactor = isLocalPlayer ? 0.4 : 0.3; // Slightly faster smoothing for local player
                
                // If distance is large, don't smooth but jump to new position
                if (Math.abs(dx) < 50) smoothed.x += dx * smoothingFactor; else smoothed.x = currentPos.x;
                if (Math.abs(dy) < 50) smoothed.y += dy * smoothingFactor; else smoothed.y = currentPos.y;
                
                return smoothed;
            }
            
            setupInput() {
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                this.pressedKeys = new Set();
                this.lastInputTime = 0;
            }
            
            handleKeyDown(e) {
                if (e.repeat) return;
                
                this.pressedKeys.add(e.code);
                
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (this.model.gameOver) {
                        this.publish(this.sessionId, "restart-game", {});
                    } else {
                        // Start bomb holding timer
                        this.spacePressStartTime = Date.now();
                        this.spacePressed = true;
                        
                        // Check if player has throw bomb ability and show strength bar
                        const localPlayer = this.model.players.get(this.viewId);
                        if (localPlayer && localPlayer.hasThrowBomb) {
                            this.showThrowStrengthBar();
                        }
                        
                        // Start the hold timer
                        this.startBombHoldTimer();
                    }
                } else if (e.code === 'KeyR') {
                    e.preventDefault();
                    // Remote detonation
                    this.publish(this.viewId, "detonate-remote", {});
                }
            }
            
            handleKeyUp(e) {
                this.pressedKeys.delete(e.code);
                
                if (e.code === 'Space') {
                    if (this.spacePressed) {
                        const holdDuration = Date.now() - this.spacePressStartTime;
                        
                        // Check if player has throw bomb ability
                        const localPlayer = this.model.players.get(this.viewId);
                        if (localPlayer && localPlayer.hasThrowBomb) {
                            // Use dynamic throw distance based on hold time
                            this.publish(this.viewId, "place-bomb", { holdDuration: holdDuration });
                        } else {
                            // Normal bomb placement logic
                            if (holdDuration >= 2500) {
                                // Long press - throw the bomb
                                this.publish(this.viewId, "throw-held-bomb", {});
                            } else {
                                // Short press - place bomb normally
                                this.publish(this.viewId, "place-bomb", {});
                            }
                        }
                        
                        this.spacePressed = false;
                        this.spacePressStartTime = 0;
                        this.clearBombHoldTimer();
                        
                        // Hide throw strength bar
                        this.hideThrowStrengthBar();
                    }
                }
            }
            
            publishMove(direction) {
                if (!this.model.gameOver) {
                    this.publish(this.viewId, "move", { direction });
                }
            }
            
            startBombHoldTimer() {
                // Clear any existing timer
                this.clearBombHoldTimer();
                
                // Check if player has throw bomb ability - if so, don't use old holding mechanism
                const localPlayer = this.model.players.get(this.viewId);
                if (localPlayer && localPlayer.hasThrowBomb) {
                    // For throw bomb ability, we don't need the old holding timer
                    return;
                }
                
                // Start new timer for normal players
                this.bombHoldTimer = setTimeout(() => {
                    if (this.spacePressed) {
                        // Space has been held for 2.5 seconds, start holding bomb
                        this.publish(this.viewId, "start-hold-bomb", {});
                    }
                }, 2500);
            }
            
            clearBombHoldTimer() {
                if (this.bombHoldTimer) {
                    clearTimeout(this.bombHoldTimer);
                    this.bombHoldTimer = null;
                }
            }
            
            showThrowStrengthBar() {
                if (this.throwStrengthBar) {
                    this.throwStrengthBar.style.display = 'block';
                    this.updateThrowStrengthBar();
                }
            }
            
            hideThrowStrengthBar() {
                if (this.throwStrengthBar) {
                    this.throwStrengthBar.style.display = 'none';
                }
            }
            
            updateThrowStrengthBar() {
                if (!this.spacePressed || !this.throwStrengthFill || !this.throwDistanceText) return;
                
                const holdDuration = Date.now() - this.spacePressStartTime;
                const maxHoldTime = 2500; // 2.5 seconds
                const holdTime = Math.min(holdDuration, maxHoldTime);
                
                // Calculate strength percentage (0-100%)
                const strengthPercent = (holdTime / maxHoldTime) * 100;
                
                // Calculate distance (1-8 tiles)
                const minDistance = 1;
                const maxDistance = 8;
                const distance = Math.floor(minDistance + (holdTime / maxHoldTime) * (maxDistance - minDistance));
                
                // Update the visual bar
                this.throwStrengthFill.style.width = strengthPercent + '%';
                this.throwDistanceText.textContent = `Distance: ${distance} tile${distance > 1 ? 's' : ''}`;
                
                // Continue updating if still holding
                if (this.spacePressed) {
                    requestAnimationFrame(() => this.updateThrowStrengthBar());
                }
            }
            
            setupUI() {
                this.livesEl = document.getElementById('lives');
                this.bombsEl = document.getElementById('bombs');
                this.fireEl = document.getElementById('fire');
                this.gameStatusEl = document.getElementById('gameStatus');
                this.playersEl = document.getElementById('players');
                this.throwStrengthBar = document.getElementById('throwStrengthBar');
                this.throwStrengthFill = document.getElementById('throwStrengthFill');
                this.throwDistanceText = document.getElementById('throwDistanceText');
                this.speedStatus = document.getElementById('speedStatus');
            }
            
            onGameStarted() {
                this.gameStatusEl.textContent = 'Game Started! Fight!';
            }
            
            onGameOver(data) {
                this.gameStatusEl.textContent = `Game Over! Winner: ${data.winnerName} - Press SPACE to restart`;
            }
            
            onPlayerListUpdated(data) {
                this.updatePlayerList(data.players);
            }
            
            onPlayerDamaged(data) {
                this.livesEl.textContent = data.lives;
            }
            
            onPowerUpCollected(data) {
                this.bombsEl.textContent = data.bombCount;
                this.fireEl.textContent = data.firePower;
                
                // Update ability UI
                this.updateAbilityUI();
            }
            
            onBombHoldingStarted(data) {
                this.gameStatusEl.textContent = '‚ö†Ô∏è Holding bomb! Press SPACE to throw!';
            }
            
            onBombThrown(data) {
                this.gameStatusEl.textContent = 'üí£ Bomb thrown!';
                // Reset status after a short delay
                setTimeout(() => {
                    this.gameStatusEl.textContent = 'Game Started! Fight!';
                }, 2000);
            }
            
            onBombAutoThrown(data) {
                const distance = data.distance || 1;
                this.gameStatusEl.textContent = `üí£ Auto-threw bomb ${distance} tiles!`;
                // Reset status after a short delay
                setTimeout(() => {
                    this.gameStatusEl.textContent = 'Game Started! Fight!';
                }, 2000);
            }
            
            onShieldBlocked(data) {
                this.gameStatusEl.textContent = 'üõ°Ô∏è Shield blocked explosion!';
                // Reset status after a short delay
                setTimeout(() => {
                    this.gameStatusEl.textContent = 'Game Started! Fight!';
                }, 2000);
            }
            
            onRemoteBombLimitReached(data) {
                this.gameStatusEl.textContent = 'üíú Remote bomb limit reached (2/2)!';
                // Reset status after a short delay
                setTimeout(() => {
                    this.gameStatusEl.textContent = 'Game Started! Fight!';
                }, 2000);
            }
            
            onPowerUpCollectedGlobal(data) {
                // Could add visual feedback here like a popup or animation
            }
            
            updateAbilityUI() {
                const localPlayer = this.model.players.get(this.viewId);
                if (!localPlayer) return;
                
                const shieldStatus = document.getElementById('shieldStatus');
                const remoteStatus = document.getElementById('remoteStatus');
                const throwStatus = document.getElementById('throwStatus');
                const speedStatus = document.getElementById('speedStatus');
                
                // Update shield status
                if (localPlayer.hasShield) {
                    shieldStatus.style.display = 'block';
                    shieldStatus.textContent = `üõ°Ô∏è Shield Active (${Math.ceil(localPlayer.shieldDuration / 1000)}s)`;
                } else {
                    shieldStatus.style.display = 'none';
                }
                
                // Update remote control status
                if (localPlayer.hasRemoteControl) {
                    remoteStatus.style.display = 'block';
                    const bombCount = localPlayer.remoteBombs.length + (localPlayer.isHoldingBomb && localPlayer.heldBomb && localPlayer.heldBomb.isRemote ? 1 : 0);
                    const timeLeft = Math.ceil(localPlayer.remoteControlDuration / 1000);
                    remoteStatus.textContent = `üéÆ Remote Control (${timeLeft}s) - ${bombCount}/2 bombs - Press R`;
                } else {
                    remoteStatus.style.display = 'none';
                }
                
                // Update throw bomb status
                if (localPlayer.hasThrowBomb) {
                    throwStatus.style.display = 'block';
                    const timeLeft = Math.ceil(localPlayer.throwBombDuration / 1000);
                    throwStatus.textContent = `üí£ Throw Bomb (${timeLeft}s) - Hold Space for distance`;
                } else {
                    throwStatus.style.display = 'none';
                }
                
                // Update speed boost status
                if (localPlayer.speedBoostDuration > 0) {
                    speedStatus.style.display = 'block';
                    const timeLeft = Math.ceil(localPlayer.speedBoostDuration / 1000);
                    speedStatus.textContent = `üí® Speed Boost (${timeLeft}s)`;
                } else {
                    speedStatus.style.display = 'none';
                }
            }
            
            updatePlayerList(players) {
                this.playersEl.innerHTML = '';
                players.forEach(player => {
                    const div = document.createElement('div');
                    div.className = player.viewId === this.viewId ? 'player-info player-local' : 'player-info player-remote';
                    div.innerHTML = `
                        Player ${player.playerId + 1} 
                        ${player.viewId === this.viewId ? '(You)' : ''}
                        <br>Lives: ${player.lives}
                        ${!player.isAlive ? ' (Dead)' : ''}
                    `;
                    this.playersEl.appendChild(div);
                });
            }
            
            update() {
                // Handle continuous movement with input buffering
                const now = Date.now();
                const localPlayer = this.model.players.get(this.viewId);
                
                // Process input buffer for smoother movement
                if (localPlayer && localPlayer.isAlive && !localPlayer.isMoving && this.pressedKeys.size > 0) {
                    // Prioritize the most recent key press
                    const keys = Array.from(this.pressedKeys);
                    const lastKey = keys[keys.length - 1];
                    
                    let direction = null;
                    if (lastKey === 'ArrowLeft' || lastKey === 'KeyA') {
                        direction = 'left';
                    } else if (lastKey === 'ArrowRight' || lastKey === 'KeyD') {
                        direction = 'right';
                    } else if (lastKey === 'ArrowUp' || lastKey === 'KeyW') {
                        direction = 'up';
                    } else if (lastKey === 'ArrowDown' || lastKey === 'KeyS') {
                        direction = 'down';
                    }
                    
                    if (direction && now - this.lastInputTime > 80) { // Input buffering
                        this.publishMove(direction);
                        this.lastInputTime = now;
                    }
                }
                
                // Update local player UI
                if (localPlayer) {
                    this.livesEl.textContent = localPlayer.lives;
                    this.bombsEl.textContent = localPlayer.bombCount;
                    this.fireEl.textContent = localPlayer.firePower;
                    
                    // Update ability UI regularly
                    this.updateAbilityUI();
                }
                
                // Render at 60fps for smooth visuals
                this.render();
            }
            
            render() {
                // Get current canvas display size for responsive scaling
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                // Clear canvas
                ctx.fillStyle = '#0a1a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Render background
                if (sprites.bg) {
                    ctx.drawImage(sprites.bg, 0, 0, canvas.width, canvas.height);
                }
                
                // Render map
                this.renderMap();
                
                // Render power-ups
                this.renderPowerUps();
                
                // Render bombs
                this.renderBombs();
                
                // Render explosions
                this.renderExplosions();
                
                // Render players
                this.renderPlayers();
            }
            
            renderMap() {
                // Center the map on the wider canvas
                const mapWidth = LEVEL_MAP[0].length * TILE_SIZE;
                const mapHeight = LEVEL_MAP.length * TILE_SIZE;
                const offsetX = (canvas.width - mapWidth) / 2;
                const offsetY = (canvas.height - mapHeight) / 2;
                
                LEVEL_MAP.forEach((row, y) => {
                    row.split('').forEach((cell, x) => {
                        const posX = offsetX + (x * TILE_SIZE);
                        const posY = offsetY + (y * TILE_SIZE);
                        
                        if (cell === 'a') {
                            // Steel wall
                            if (sprites['wall-steel']) {
                                ctx.drawImage(sprites['wall-steel'], posX, posY, TILE_SIZE, TILE_SIZE);
                            } else {
                                ctx.fillStyle = '#666';
                                ctx.fillRect(posX, posY, TILE_SIZE, TILE_SIZE);
                            }
                        } else if (cell === 'z') {
                            // Check if this destructible block still exists
                            const blockKey = `${x},${y}`;
                            if (this.model.destructibleBlocks.has(blockKey)) {
                                // Render the original brick block
                                if (sprites['brick-red']) {
                                    ctx.drawImage(sprites['brick-red'], posX, posY, TILE_SIZE, TILE_SIZE);
                                } else {
                                    ctx.fillStyle = '#a52a2a';
                                    ctx.fillRect(posX, posY, TILE_SIZE, TILE_SIZE);
                                }
                            } else {
                                // Block was destroyed - render green tile instead
                                ctx.fillStyle = '#228B22'; // Forest green color
                                ctx.fillRect(posX, posY, TILE_SIZE, TILE_SIZE);
                                
                                // Add a subtle pattern to make it look like grass/tile
                                ctx.fillStyle = '#32CD32'; // Lime green for pattern
                                ctx.fillRect(posX + 2, posY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                                
                                // Add some texture dots
                                ctx.fillStyle = '#228B22';
                                for (let i = 0; i < 4; i++) {
                                    for (let j = 0; j < 4; j++) {
                                        if ((i + j) % 2 === 0) {
                                            ctx.fillRect(
                                                posX + 4 + i * 8, 
                                                posY + 4 + j * 8, 
                                                4, 4
                                            );
                                        }
                                    }
                                }
                            }
                        }
                    });
                });
            }
            
            renderPowerUps() {
                const offsetX = (canvas.width - (LEVEL_MAP[0].length * TILE_SIZE)) / 2;
                const offsetY = (canvas.height - (LEVEL_MAP.length * TILE_SIZE)) / 2;
                
                for (const powerUp of this.model.powerUps) {
                    const spriteName = `powerup-${powerUp.type}`;
                    if (sprites[spriteName]) {
                        ctx.drawImage(sprites[spriteName], powerUp.pos.x + offsetX, powerUp.pos.y + offsetY, TILE_SIZE, TILE_SIZE);
                    } else {
                        // Color-coded fallback for different powerup types
                        let powerupColor;
                        switch(powerUp.type) {
                            case 'bomb':
                                powerupColor = '#ffff00'; // Yellow
                                break;
                            case 'fire':
                                powerupColor = '#ff8000'; // Orange
                                break;
                            case 'speed':
                                powerupColor = '#00ff00'; // Green
                                break;
                            case 'shield':
                                powerupColor = '#00ffff'; // Cyan
                                break;
                            case 'remote':
                                powerupColor = '#ff00ff'; // Magenta
                                break;
                            case 'throw':
                                powerupColor = '#ff8800'; // Orange
                                break;
                            default:
                                powerupColor = '#ffffff'; // White
                        }
                        ctx.fillStyle = powerupColor;
                        ctx.fillRect(powerUp.pos.x + offsetX + 4, powerUp.pos.y + offsetY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        
                        // Add powerup type indicator
                        ctx.fillStyle = '#000';
                        ctx.font = '8px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(powerUp.type.toUpperCase().charAt(0), powerUp.pos.x + offsetX + TILE_SIZE/2, powerUp.pos.y + offsetY + TILE_SIZE/2 + 3);
                    }
                }
            }
            
            renderBombs() {
                const offsetX = (canvas.width - (LEVEL_MAP[0].length * TILE_SIZE)) / 2;
                const offsetY = (canvas.height - (LEVEL_MAP.length * TILE_SIZE)) / 2;
                
                // Render regular bombs
                for (const bomb of this.model.bombs) {
                    this.renderBomb(bomb, offsetX, offsetY);
                }
                
                // Render held bombs
                for (const player of this.model.players.values()) {
                    if (player.isHoldingBomb && player.heldBomb) {
                        this.renderBomb(player.heldBomb, offsetX, offsetY, true);
                    }
                }
            }
            
            renderBomb(bomb, offsetX, offsetY, isHeld = false) {
                if (sprites.bomb) {
                    // Animated bomb rendering using time-based animation data
                    const totalWidth = sprites.bomb.width; // 58 pixels
                    const frameWidth = Math.floor(totalWidth / 3); // 19 pixels per frame
                    const spriteHeight = sprites.bomb.height; // 18 pixels
                    
                    // Use the bomb animation data structure
                    const frameIndex = bombAnimation.frames[bomb.animationFrame % bombAnimation.frames.length];
                    const srcX = frameIndex * frameWidth;
                    const srcY = 0;
                    
                    ctx.drawImage(
                        sprites.bomb,
                        srcX, srcY, frameWidth, spriteHeight,
                        bomb.pos.x + offsetX, bomb.pos.y + offsetY, TILE_SIZE, TILE_SIZE
                    );
                    
                    // Add visual indicator for held bombs
                    if (isHeld) {
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(bomb.pos.x + offsetX - 2, bomb.pos.y + offsetY - 2, TILE_SIZE + 4, TILE_SIZE + 4);
                        
                        // Add warning text
                        ctx.fillStyle = '#ff0000';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('HELD!', bomb.pos.x + offsetX + TILE_SIZE/2, bomb.pos.y + offsetY - 5);
                    }
                    
                    // Add visual indicator for remote bombs
                    if (bomb.isRemote) {
                        ctx.strokeStyle = '#ff00ff';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(bomb.pos.x + offsetX - 2, bomb.pos.y + offsetY - 2, TILE_SIZE + 4, TILE_SIZE + 4);
                        
                        // Add remote indicator
                        ctx.fillStyle = '#ff00ff';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('REMOTE', bomb.pos.x + offsetX + TILE_SIZE/2, bomb.pos.y + offsetY - 5);
                    }
                } else {
                    ctx.fillStyle = isHeld ? '#ff0000' : bomb.isRemote ? '#ff00ff' : '#222';
                    ctx.beginPath();
                    ctx.arc(bomb.pos.x + offsetX + TILE_SIZE/2, bomb.pos.y + offsetY + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add text indicator for remote bombs
                    if (bomb.isRemote) {
                        ctx.fillStyle = '#000';
                        ctx.font = '8px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('R', bomb.pos.x + offsetX + TILE_SIZE/2, bomb.pos.y + offsetY + TILE_SIZE/2);
                    }
                }
            }
            
            renderExplosions() {
                const offsetX = (canvas.width - (LEVEL_MAP[0].length * TILE_SIZE)) / 2;
                const offsetY = (canvas.height - (LEVEL_MAP.length * TILE_SIZE)) / 2;
                
                for (const explosion of this.model.explosions) {
                    if (sprites.explosion) {
                        ctx.drawImage(sprites.explosion, explosion.pos.x + offsetX, explosion.pos.y + offsetY, TILE_SIZE, TILE_SIZE);
                    } else {
                        ctx.fillStyle = 'rgba(255, 165, 0, 0.8)';
                        ctx.fillRect(explosion.pos.x + offsetX, explosion.pos.y + offsetY, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
            
            renderPlayers() {
                const offsetX = (canvas.width - (LEVEL_MAP[0].length * TILE_SIZE)) / 2;
                const offsetY = (canvas.height - (LEVEL_MAP.length * TILE_SIZE)) / 2;
                
                for (const player of this.model.players.values()) {
                    if (!player.isAlive) continue;
                    
                    // Use smoothed position for rendering
                    const smoothedPos = this.smoothPlayerPos(player);
                    
                    if (sprites.bomberman) {
                        // Calculate sprite frame
                        const animData = animations[player.currentAnimation];
                        const frameIndex = animData.frames[player.animationFrame % animData.frames.length];
                        const spriteWidth = sprites.bomberman.width / 7; // 7 columns
                        const spriteHeight = sprites.bomberman.height / 4; // 4 rows
                        
                        const srcX = frameIndex * spriteWidth;
                        const srcY = animData.row * spriteHeight;
                        
                        ctx.drawImage(
                            sprites.bomberman,
                            srcX, srcY, spriteWidth, spriteHeight,
                            smoothedPos.x + offsetX, smoothedPos.y + offsetY, TILE_SIZE, TILE_SIZE
                        );
                    } else {
                        // Fallback colored rectangles
                        const colors = ['#fff', '#ff0', '#0ff', '#f0f'];
                        ctx.fillStyle = colors[player.playerId % 4];
                        ctx.fillRect(smoothedPos.x + offsetX + 2, smoothedPos.y + offsetY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    }
                    
                    // Highlight local player
                    if (player.viewId === this.viewId) {
                        ctx.strokeStyle = '#0f0';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(smoothedPos.x + offsetX - 2, smoothedPos.y + offsetY - 2, TILE_SIZE + 4, TILE_SIZE + 4);
                    }
                    
                    // Draw ability indicators above player
                    this.renderPlayerAbilityIndicator(player, smoothedPos, offsetX, offsetY);
                }
            }
            
            renderPlayerAbilityIndicator(player, pos, offsetX, offsetY) {
                const centerX = pos.x + offsetX + TILE_SIZE / 2;
                const centerY = pos.y + offsetY - 10; // Position above player
                
                // Draw shield indicator
                if (player.hasShield) {
                    this.drawStar(centerX, centerY, '#00ffff', 'üõ°Ô∏è');
                }
                
                // Draw remote control indicator
                if (player.hasRemoteControl) {
                    this.drawStar(centerX, centerY + 15, '#ff00ff', 'üéÆ');
                }
                
                // Draw throw bomb indicator
                if (player.hasThrowBomb) {
                    this.drawStar(centerX, centerY + 30, '#ff8800', 'üí£');
                }
            }
            
            drawStar(x, y, color, symbol) {
                // Draw a colored background circle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw a border
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw the symbol
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, x, y);
            }
            
            detach() {
                // Clean up LobbyRelayView when view is detached
                if (this.lobbyRelay) {
                    this.lobbyRelay.detach();
                    this.lobbyRelay = null;
                }
            }
        }
        
        // Background Music Management
        let backgroundMusic;
        let isMusicPlaying = true;
        
        // Sound Effects Management
        let explosionSound, powerupSound, deathSound;
        
        function initializeMusic() {
            backgroundMusic = document.getElementById('backgroundMusic');
            
            // Set volume to a reasonable level
            backgroundMusic.volume = 0.3;
            
            // Start playing when user interacts (browser autoplay policy)
            const startMusic = () => {
                if (isMusicPlaying && backgroundMusic.paused) {
                    backgroundMusic.play().catch(e => {
                        console.log('Could not autoplay music:', e);
                    });
                }
                // Remove event listeners after first interaction
                document.removeEventListener('click', startMusic);
                document.removeEventListener('keydown', startMusic);
            };
            
            // Add event listeners for user interaction
            document.addEventListener('click', startMusic);
            document.addEventListener('keydown', startMusic);
            
            // Music toggle functionality
            const musicToggle = document.getElementById('musicToggle');
            musicToggle.addEventListener('click', () => {
                if (isMusicPlaying) {
                    backgroundMusic.pause();
                    isMusicPlaying = false;
                    musicToggle.textContent = 'Music: OFF';
                    musicToggle.style.background = '#ff4444';
                } else {
                    backgroundMusic.play();
                    isMusicPlaying = true;
                    musicToggle.textContent = 'Music: ON';
                    musicToggle.style.background = '#00ff88';
                }
            });
            
            console.log('Background music initialized');
        }
        
        function initializeSoundEffects() {
            explosionSound = document.getElementById('explosionSound');
            powerupSound = document.getElementById('powerupSound');
            deathSound = document.getElementById('deathSound');
            
            // Set volumes for sound effects
            explosionSound.volume = 0.4;
            powerupSound.volume = 0.5;
            deathSound.volume = 0.6;
            
            console.log('Sound effects initialized');
        }
        
        function playExplosionSound() {
            if (explosionSound) {
                explosionSound.currentTime = 0;
                explosionSound.play().catch(e => {
                    console.log('Could not play explosion sound:', e);
                });
            }
        }
        
        function playPowerupSound() {
            if (powerupSound) {
                powerupSound.currentTime = 0;
                powerupSound.play().catch(e => {
                    console.log('Could not play powerup sound:', e);
                });
            }
        }
        
        function playDeathSound() {
            if (deathSound) {
                deathSound.currentTime = 0;
                deathSound.play().catch(e => {
                    console.log('Could not play death sound:', e);
                });
            }
        }
        
        // Start the game
        function startGame() {
            // Initialize background music and sound effects
            initializeMusic();
            initializeSoundEffects();
            
            document.getElementById('gameStatus').textContent = 'Connecting to MultiSynq...';
            
            // Get session info from URL hash or localStorage
            let sessionName;
            let sessionPassword = 'bomberman-default';
            let lobbySessionData = null;
            
            // Check localStorage for lobby session data
            const storedSession = localStorage.getItem('bomberman_session');
            if (storedSession) {
                try {
                    lobbySessionData = JSON.parse(storedSession);
                    sessionName = lobbySessionData.sessionId;
                    console.log('Using session from localStorage:', sessionName);
                    // Clear localStorage after reading
                    localStorage.removeItem('bomberman_session');
                } catch (e) {
                    console.error('Failed to parse stored session data:', e);
                }
            }
            
            // Fallback to URL hash
            if (!sessionName && window.location.hash) {
                sessionName = window.location.hash.slice(1);
                console.log('Using session from URL hash:', sessionName);
            }
            
            // Generate new session if none found
            if (!sessionName) {
                sessionName = `bomberman-${Math.random().toString(36).substr(2, 8)}`;
                window.location.hash = sessionName;
                console.log('Generated new session:', sessionName);
            }
            
            console.log('Joining session:', sessionName, 'with password:', sessionPassword);
            
            // Join MultiSynq session with consistent parameters
            Multisynq.Session.join({
                apiKey: '2ggnQt2MuoVu2xcPjaevCeZUyyrX68wFDTDjL2dCOn',
                appId: 'io.multisynq.bomberman-game',
                model: GameModel,
                view: GameView,
                name: sessionName,
                password: sessionPassword,
                viewData: {
                    playerName: lobbySessionData?.playerName || 'Player',
                    isHost: lobbySessionData?.isHost || false,
                    sessionId: sessionName
                },
                step: "auto"
            }).then(session => {
                console.log('MultiSynq session joined successfully!');
                console.log('Session ID:', session.id);
                console.log('Session name:', sessionName);
                
                // Store session reference for resize handler
                window.gameSession = session;
                
                document.getElementById('gameStatus').textContent = `Connected! Session: ${sessionName}`;
                
                // Create shareable URL
                const shareUrl = `${window.location.origin}${window.location.pathname}#${sessionName}`;
                console.log('üéÆ Share this URL with friends to play together:', shareUrl);
                
                // Add click to copy URL functionality
                document.addEventListener('click', () => {
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(shareUrl).then(() => {
                            console.log('URL copied to clipboard!');
                            document.getElementById('gameStatus').textContent = `Connected! URL copied to clipboard`;
                            setTimeout(() => {
                                document.getElementById('gameStatus').textContent = `Connected! Session: ${sessionName}`;
                            }, 2000);
                        }).catch(() => {
                            console.log('Could not copy URL');
                        });
                    }
                });
                
            }).catch(error => {
                console.error('Failed to join MultiSynq session:', error);
                console.error('Error details:', error.message);
                document.getElementById('gameStatus').textContent = 'Failed to connect. Playing offline.';
                
                console.log('Multiplayer unavailable. Please check your connection or API key.');
            });
        }
        
        // Remove the fallback session approach - we want consistent sessions
        // function trySimpleSession() {
        //     console.log('Trying simple session without password...');
        //     
        //     Multisynq.Session.join({
        //         apiKey: '2ggnQt2MuoVu2xcPjaevCeZUyyrX68wFDTDjL2dCOn',
        //         appId: 'io.multisynq.bomberman-simple',
        //         model: GameModel,
        //         view: GameView,
        //         step: "auto"
        //     }).then(session => {
        //         console.log('Simple session joined successfully!');
        //         console.log('Session ID:', session.id);
        //         
        //         // Store session reference for resize handler
        //         window.gameSession = session;
        //         
        //         document.getElementById('gameStatus').textContent = `Connected! Share URL to play`;
        //         
        //         const shareUrl = `${window.location.origin}${window.location.pathname}#${session.id}`;
        //         console.log('üéÆ Share this URL:', shareUrl);
        //         
        //         if (!window.location.hash) {
        //             window.location.hash = session.id;
        //         }
        //         
        //     }).catch(error => {
        //         console.error('Simple session also failed:', error);
        //         document.getElementById('gameStatus').textContent = 'Connection failed. Game will run in single-player mode.';
        //         
        //         // Could add offline mode here
        //         console.log('You can still play the game locally, but multiplayer features won\'t work.');
        //     });
        // }
        
        // Initialize
        document.getElementById('gameStatus').textContent = 'Loading sprites...';
        loadSprites();
        
        // Handle window resize for responsive canvas
        window.addEventListener('resize', () => {
            // The CSS will handle the scaling automatically
            // We just need to trigger a re-render if game is running
            if (window.gameSession && window.gameSession.view && window.gameSession.view.render) {
                window.gameSession.view.render();
            }
        });
    </script>
</body>
</html> 